import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/* ------------------------------------------------------------------ *
 * Mock the exact module id that the component imports
 * (saferoomIntakeForm.tsx uses:  ../FormContext)
 * ------------------------------------------------------------------ */
jest.mock('../FormContext', () => {
  const React = require('react') as typeof import('react');
  // Avoid TS generic to keep test strictness simple
  const Context = (React as any).createContext(null);

  return {
    __esModule: true,
    FormContext: Context,
    useFormContext: () => {
      const v = React.useContext(Context as any);
      if (!v) throw new Error('useFormContext used outside Provider in test');
      return v;
    },
  };
});

// pull the mocked context back (so we can render with a Provider)
import { FormContext } from '../FormContext';
import SafeRoomIntakeForm from './saferoomIntakeForm';

/* ------------------------------- Helpers ------------------------------- */

// Testing Library's TextMatch type: string | RegExp | (content,node)=>boolean
type TextMatch = Parameters<typeof screen.getByLabelText>[0];

/** Open a MUI Select by its label (mouseDown on the input opens the menu) */
const openSelectByLabel = (label: TextMatch) => {
  const input = screen.getByLabelText(label, { selector: 'input' });
  fireEvent.mouseDown(input);
};

/** Build a Provider with a minimal safe form shape that the component uses */
function withForm(overrides?: Partial<any>) {
  // minimal + correct keys (only the ones used in this component)
  const baseFormData = {
    cdpDetails: { versionCDPRequired: '' },      // updated in useEffect
    safeRoomDetails: { dataLoadRequired: '' },   // bound to the Select
    ...(overrides || {}),
  };

  // updater that supports both object & functional setState forms
  const setFormData = jest.fn((updater: any) => {
    if (typeof updater === 'function') {
      const next = updater(baseFormData);
      Object.assign(baseFormData, next);
    } else {
      Object.assign(baseFormData, updater);
    }
  });

  const value = {
    formData: baseFormData,
    setFormData,
    requiredFields: [],
    resetFormData: jest.fn(),
  };

  const Provider = ({ children }: { children: React.ReactNode }) => (
    // cast for test only
    <(FormContext as any).Provider value={value}>{children}</(FormContext as any).Provider>
  );

  return { Provider, setFormData, formData: baseFormData };
}

/* ====================================================================== *
 *                                 Tests
 * ====================================================================== */

describe('SafeRoomIntakeForm', () => {
  test('renders overview copy and the Select (smoke)', () => {
    const { Provider } = withForm();

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    // a few stable pieces of UI
    expect(screen.getByText(/Saferoom Overview/i)).toBeInTheDocument();
    expect(
      screen.getByText(/Please select the required data load capability for Saferoom/i)
    ).toBeInTheDocument();

    // The select should be queryable via its InputLabel text
    // (your TSX uses: <InputLabel id="data-load-capability-sf-label">Select the Saferoom Data Load Capability</InputLabel>)
    expect(
      screen.getByLabelText(/Select the Saferoom Data Load Capability/i)
    ).toBeInTheDocument();
  });

  test('changing Select → calls setFormData and sets versionCDPRequired via useEffect ("Cloud Storage")', async () => {
    const { Provider, setFormData, formData } = withForm();

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);

    // The MenuItems are "Cloud Storage" and "Big Query" in your TSX
    fireEvent.click(await screen.findByText('Cloud Storage'));

    // The component calls setFormData when value changes
    expect(setFormData).toHaveBeenCalled();

    // The useEffect reads safeRoomDetails.dataLoadRequired and sets cdpDetails.versionCDPRequired
    await waitFor(() =>
      expect(formData.cdpDetails.versionCDPRequired).toBe('File to BQ version')
    );
  });

  test('changing Select → sets versionCDPRequired for "Big Query"', async () => {
    const { Provider, formData } = withForm({
      // start empty; the effect will compute the version when the Select changes
      safeRoomDetails: { dataLoadRequired: '' },
    });

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(await screen.findByText('Big Query'));

    await waitFor(() =>
      expect(formData.cdpDetails.versionCDPRequired).toBe('BQ to BQ version')
    );
  });

  test('keeps version empty if an unsupported value is selected (defensive)', async () => {
    // Start with a custom value; component should clear to '' per your useEffect logic
    const { Provider, formData } = withForm({
      safeRoomDetails: { dataLoadRequired: 'Unsupported' },
    });

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    // Trigger a re-evaluation of the effect by selecting one of the known items then toggling back to unsupported
    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(await screen.findByText('Cloud Storage'));
    await waitFor(() =>
      expect(formData.cdpDetails.versionCDPRequired).toBe('File to BQ version')
    );

    // Manually set back to an unsupported value and re-render to simulate another pass
    formData.safeRoomDetails.dataLoadRequired = 'Unknown';
    // Force a micro task for effect to run again (in real app this would be set via UI)
    await waitFor(() =>
      expect(formData.cdpDetails.versionCDPRequired).toBe('')
    );
  });
});
