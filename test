import { renderHook, act } from '@testing-library/react';
import useApiService from './useApiService';
import type { HttpRequest } from './types';

/* ---------- mock external deps ---------- */
jest.mock('@wf/react-library', () => ({
  __esModule: true,
  useAppGlobalState: jest.fn(),
  useConfig: jest.fn(),
}));

// mock the **named** export, not default
jest.mock('./processHttp', () => ({
  __esModule: true,
  processHttpRequest: jest.fn(),
}));

/* ---------- typed handles to mocks ---------- */
import * as reactlib from '@wf/react-library';
import { processHttpRequest } from './processHttp';

const useAppGlobalStateMock = reactlib.useAppGlobalState as jest.Mock;
const useConfigMock = reactlib.useConfig as jest.Mock;
// cast so we can call .mockResolvedValue, .mockRejectedValue, etc.
const processHttpRequestMock = processHttpRequest as unknown as jest.Mock;

/* ---------- helpers ---------- */
const BASE = 'https://api.example.com';

// Build a request that satisfies your HttpRequest type.
// If your HttpRequest requires more fields, add them here.
const makeReq = (endpoint: string): HttpRequest => ({
  method: 'GET',
  endpoint,
  responseType: 'json',
});

beforeEach(() => {
  jest.clearAllMocks();
  // ensure env.API_BASE_ENDPOINT exists for the hook
  useConfigMock.mockReturnValue({ API_BASE_ENDPOINT: BASE });
});

/* ---------- tests ---------- */
describe('useApiService', () => {
  test('calls processHttpRequest with (request, access_token, baseEndpoint)', async () => {
    useAppGlobalStateMock.mockReturnValue({ token: { access_token: 'TOK' } });
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/things');

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledTimes(1);
    expect(processHttpRequestMock).toHaveBeenCalledWith(req, 'TOK', BASE);
  });

  test('passes undefined token when global state has no token', async () => {
    useAppGlobalStateMock.mockReturnValue({ token: undefined });
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/stuff');

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledWith(req, undefined, BASE);
  });

  test('returns the resolved value from processHttpRequest', async () => {
    useAppGlobalStateMock.mockReturnValue({ token: { access_token: 'TOK' } });
    const payload = { id: 7, name: 'thing' };
    processHttpRequestMock.mockResolvedValue(payload);

    const { result } = renderHook(() => useApiService());

    const value = await result.current.makeRequest(makeReq('/thing/7'));
    expect(value).toBe(payload);
  });

  test('propagates errors from processHttpRequest', async () => {
    useAppGlobalStateMock.mockReturnValue({ token: { access_token: 'TOK' } });
    const err = new Error('network down');
    processHttpRequestMock.mockRejectedValue(err);

    const { result } = renderHook(() => useApiService());
    await expect(result.current.makeRequest(makeReq('/oops'))).rejects.toThrow('network down');
  });
});
