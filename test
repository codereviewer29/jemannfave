// File: src/intake-components/__tests__/CDMNextIntakeForm.big.test.tsx
import React from 'react';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// ---------- Router + MUI helpers ----------
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  Form: ({ children, onSubmit }: { children: React.ReactNode; onSubmit?: React.FormEventHandler }) => (
    <form onSubmit={onSubmit}>{children}</form>
  ),
  Link: ({ children, ...rest }: any) => <a {...rest}>{children}</a>,
}));

jest.mock('@mui/material', () => {
  const actual = jest.requireActual('@mui/material');
  return {
    ...actual,
    Tooltip: ({ title, children, componentsProps }: any) => (
      <div data-testid="tooltip">
        <div data-testid="tooltip-title">{title}</div>
        {/* carry children so structure stays intact */}
        <div data-testid="tooltip-children" {...(componentsProps || {})}>{children}</div>
      </div>
    ),
  };
});

// ---------- API hook ----------
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// ---------- Form context ----------
let ctxFormData: any;
let setFormData: jest.Mock;

jest.mock('../FormContext', () => ({
  useFormContext: () => ({
    formData: ctxFormData,
    setFormData,
  }),
}));

// ---------- Import SUT after mocks ----------
import CDMNextIntakeForm from '../cdmNextIntakeForm';

// ---------- Helpers ----------
const baseCdmNext = () => ({
  selectedPatterns: [] as string[],
  hadoopPlatforms: [] as string[],
  nodeDetails: '',
  tptInstalled: 'no',
  tptNodeDetails: '',
  nasAvailable: 'no',
  apiResponseSupported: 'no',
  streamingSourceRealTime: 'Kafka',
  sourceSystems: [] as string[],
  jecksCert: 'no',
  storagePlatforms: [] as string[],
  storagePlatformsSts: [] as string[],
  serviceAccountAvailability: 'no',
  serviceAccountName: '',
  preferedServiceAccountName: '',
  venafiFileName: '',
  venafiFileContent: '',
});

function resetCtx(overrides?: Partial<any>) {
  ctxFormData = {
    applicationDetails: { applicationID: 'APP-1', auNumber: 'AU-9' },
    cdmNextDetails: { ...baseCdmNext(), ...(overrides?.cdmNextDetails || {}) },
    ...(overrides || {}),
  };
  setFormData = jest.fn((next: any) => {
    ctxFormData = typeof next === 'function' ? next(ctxFormData) : next;
  });
  makeRequest.mockReset();
}

const renderForm = (validationErrors: Record<string, string> = {}) =>
  render(<CDMNextIntakeForm validationErrors={validationErrors} />);

// ---------- Tests ----------
describe('CDMNextIntakeForm (big coverage)', () => {
  beforeEach(() => resetCtx());

  test('renders base headings, labels and tooltip content', () => {
    const { container } = renderForm();

    expect(screen.getByText(/Migration Patterns/i)).toBeInTheDocument();
    // Giant patterns tooltip renders tables & headings inline
    expect(screen.getByTestId('tooltip-title')).toBeInTheDocument();
    expect(within(screen.getByTestId('tooltip-title')).getByText(/PUSH PATTERNS TABLE/i)).toBeInTheDocument();
    expect(within(screen.getByTestId('tooltip-title')).getByText(/PULL PATTERNS/i)).toBeInTheDocument();

    expect(container).toMatchSnapshot();
  });

  // -------- File upload (Venafi) --------
  test('uploads Venafi certificate successfully, then allows removing it', async () => {
    // showVenafi is true when certain patterns chosen; use one from screenshots
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), selectedPatterns: ['G2C - EDL Historical Data Migration'] },
    });

    makeRequest.mockResolvedValueOnce({
      data: { status: 'Success', data: { fileName: 'cert.pem', fileContent: 'ABC=' } },
    });

    renderForm();

    // Upload button is a label wrapping a hidden input[type=file]
    const input = screen.getByLabelText(/upload/i, { selector: 'input[type="file"]' });
    const file = new File([new Uint8Array([1, 2, 3])], 'cert.pem', { type: 'application/x-pem-file' });
    await userEvent.upload(input, file);

    // success UI copy
    expect(await screen.findByText(/File Uploaded Successfully/i)).toBeInTheDocument();
    // context updated with file name
    expect(setFormData).toHaveBeenCalled();
    const last = setFormData.mock.calls.at(-1)?.[0];
    const latest = typeof last === 'function' ? last(ctxFormData) : last;
    expect(latest.cdmNextDetails.venafiFileName).toBe('cert.pem');

    // Remove file
    const removeBtn = screen.getByRole('button', { name: /Remove file/i });
    await userEvent.click(removeBtn);
    expect(setFormData).toHaveBeenCalled();
  });

  test('file upload shows error message when backend returns error', async () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), selectedPatterns: ['G2C - EDL Historical Data Migration'] },
    });
    makeRequest.mockResolvedValueOnce({ data: { status: 'Error', message: 'Bad certificate' } });

    renderForm();

    const input = screen.getByLabelText(/upload/i, { selector: 'input[type="file"]' });
    await userEvent.upload(input, new File(['xx'], 'bad.pem', { type: 'application/x-pem-file' }));

    expect(await screen.findByText(/Bad certificate/i)).toBeInTheDocument();
  });

  // -------- Validate nodes --------
  test('validate nodes: empty input shows validation message', async () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), hadoopPlatforms: ['MapR'] },
    });
    renderForm();

    await userEvent.click(screen.getByRole('button', { name: /Validate/i }));
    expect(screen.getByText(/Please enter at least one node/i)).toBeInTheDocument();
  });

  test('validate nodes: API success shows Success', async () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), hadoopPlatforms: ['MapR'], nodeDetails: 'node1,node2' },
    });
    makeRequest.mockResolvedValueOnce({ data: { status: 'Success', invalidNodes: [] } });

    renderForm();

    await userEvent.click(screen.getByRole('button', { name: /Validate/i }));
    expect(await screen.findByText(/Success/i)).toBeInTheDocument();
  });

  test('validate nodes: API error lists invalid nodes', async () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), hadoopPlatforms: ['MapR'], nodeDetails: 'bad1,bad2' },
    });
    makeRequest.mockResolvedValueOnce({ data: { status: 'Error', invalidNodes: ['bad1', 'bad2'] } });

    renderForm();

    await userEvent.click(screen.getByRole('button', { name: /Validate/i }));
    expect(await screen.findByText(/Invalid nodes:/i)).toBeInTheDocument();
    expect(screen.getByText(/bad1, bad2/i)).toBeInTheDocument();
  });

  test('validate nodes: API throws shows generic error message', async () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), hadoopPlatforms: ['MapR'], nodeDetails: 'n1' },
    });
    makeRequest.mockRejectedValueOnce(new Error('boom'));

    renderForm();

    await userEvent.click(screen.getByRole('button', { name: /Validate/i }));
    expect(await screen.findByText(/An error occurred while validating nodes/i)).toBeInTheDocument();
  });

  // -------- Conditional UI: platforms, radios, sections --------
  test('hadoop validate button shows when platforms set and not all Cloudera', () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), hadoopPlatforms: ['MapR'] },
    });
    renderForm();
    expect(screen.getByRole('button', { name: /Validate/i })).toBeInTheDocument();
  });

  test('service account availability yes vs no renders different fields', () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), serviceAccountAvailability: 'yes' },
    });
    const { rerender } = renderForm();
    expect(screen.getByLabelText(/Service Account Name/i)).toBeInTheDocument();

    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), serviceAccountAvailability: 'no' },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    expect(screen.getByLabelText(/Preferred Service Account Name/i)).toBeInTheDocument();
  });

  test('TPT installed no → node textarea; yes → thank you text', () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), tptInstalled: 'no' },
    });
    const { rerender } = renderForm();
    expect(screen.getByLabelText(/Enter the Node details here/i)).toBeInTheDocument();

    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), tptInstalled: 'yes' },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    expect(screen.getByText(/Thank you for the confirmation/i)).toBeInTheDocument();
  });

  test('NAS available yes vs no shows correct messages', () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), nasAvailable: 'yes' },
    });
    const { rerender } = renderForm();
    expect(screen.getByText(/CDM Next will provide reference implementation/i)).toBeInTheDocument();

    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), nasAvailable: 'no' },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    // message container exists even if empty; assert absence of the "will provide reference" text
    expect(screen.queryByText(/will provide reference implementation/i)).not.toBeInTheDocument();
  });

  test('API pattern section + streaming "Others" warning + direct SOR section', () => {
    resetCtx({
      cdmNextDetails: {
        ...baseCdmNext(),
        selectedPatterns: ['G2C - API', 'G2C - Real/Near Real Time', 'G2C - Direct SOR Data'],
        streamingSourceRealTime: 'Others',
      },
    });
    renderForm();

    expect(screen.getByRole('heading', { name: /G2C - API/i })).toBeInTheDocument();
    expect(screen.getByText(/Only .*Kafka.* is Supported/i)).toBeInTheDocument();
    expect(screen.getByRole('heading', { name: /G2C - Direct SOR Data/i })).toBeInTheDocument();
  });

  test('Direct BQ Push and File Push patterns render and show platform selects', () => {
    resetCtx({
      cdmNextDetails: {
        ...baseCdmNext(),
        selectedPatterns: [
          'G2C - Direct BQ Push',
          'G2C - File Push Pattern - Cloud Storage API',
          'G2C - File Push Pattern - STS Agent',
        ],
      },
    });
    renderForm();

    expect(screen.getByRole('heading', { name: /G2C - Direct BQ Push/i })).toBeInTheDocument();
    // storage platform selects – assert their input labels exist
    expect(screen.getByLabelText(/Please select the platform in which files are stored/i)).toBeInTheDocument();
    expect(screen.getAllByLabelText(/Please select the platform in which files are stored/i).length).toBeGreaterThan(1);
  });

  test('source systems supported vs Others not supported, plus JCEKS yes/no', () => {
    // supported
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), sourceSystems: ['Oracle', 'SQL Server'] },
    });
    const { rerender } = renderForm();
    expect(screen.getByText(/These sources are supported/i)).toBeInTheDocument();

    // not supported
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), sourceSystems: ['Others'] },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    expect(screen.getByText(/Others are not Supported/i)).toBeInTheDocument();

    // JCEKS YES
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), jecksCert: 'yes' },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    expect(screen.getAllByText(/Confluence link/i)[0]).toBeInTheDocument();

    // JCEKS NO
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), jecksCert: 'no' },
    });
    rerender(<CDMNextIntakeForm validationErrors={{}} />);
    expect(screen.getAllByText(/Confluence link/i)[0]).toBeInTheDocument();
  });

  test('unknown pattern renders "Details coming soon..." card', () => {
    resetCtx({
      cdmNextDetails: { ...baseCdmNext(), selectedPatterns: ['Some New Pattern'] },
    });
    renderForm();

    expect(screen.getByText(/Details coming soon/i)).toBeInTheDocument();
  });
});
