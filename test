// src/services/useApiService.test.tsx
import { renderHook, act } from '@testing-library/react';
import * as reactlib from '@wf/react-library'; // we'll spy on these
import processHttpRequest from './processHttp'; // we'll mock this default
import type { HttpRequest } from './types';
import useApiService from './useApiService';

// --- mock the default export from ./processHttp
jest.mock('./processHttp', () => ({
  __esModule: true,
  default: jest.fn(),
}));

// typed handles to the spies
const useAppGlobalStateSpy = jest.spyOn(reactlib, 'useAppGlobalState');
const useConfigSpy = jest.spyOn(reactlib, 'useConfig');

// handy constants
const BASE = 'https://api.example.com';
const TOKEN = { access_token: 'tok_123' };

const processHttpRequestMock = processHttpRequest as unknown as jest.Mock;

// convenient helper to make a minimally typed request
const makeReq = (endpoint: string): HttpRequest =>
  ({ method: 'GET', endpoint, responseType: 'json' } as unknown as HttpRequest);

beforeEach(() => {
  jest.clearAllMocks();

  // default environment + token for most tests
  useConfigSpy.mockReturnValue({ API_BASE_ENDPOINT: BASE } as any);
  useAppGlobalStateSpy.mockReturnValue({ token: TOKEN } as any);
});

describe('useApiService', () => {
  test('calls processHttpRequest with (request, access_token, baseEndpoint)', async () => {
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/things');

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledTimes(1);
    expect(processHttpRequestMock).toHaveBeenCalledWith(req, TOKEN.access_token, BASE);
  });

  test('passes undefined token when global state has no token', async () => {
    useAppGlobalStateSpy.mockReturnValue({ token: undefined } as any);
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/stuff');

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledWith(req, undefined, BASE);
  });

  test('returns the resolved value from processHttpRequest', async () => {
    const payload = { id: 42, name: 'answer' };
    processHttpRequestMock.mockResolvedValue(payload);

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/thing/42');

    // act() returns the callback's return; we re-await the hook call for clarity
    const value = await act(async () => result.current.makeRequest(req));
    expect(value).toBe(payload);
  });

  test('propagates errors from processHttpRequest', async () => {
    const err = new Error('network down');
    processHttpRequestMock.mockRejectedValue(err);

    const { result } = renderHook(() => useApiService());
    const req = makeReq('/oops');

    await expect(result.current.makeRequest(req)).rejects.toThrow('network down');
  });
});
