// src/provision/provision-list.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

// ---- Fixtures -------------------------------------------------------------

const projectEnvList = [
  { id: 1, projectId: 'abc-999', projectid: 'abc-999', env_id: 'dev', env: 'dev' },
  { id: 2, projectId: 'abc-999', projectid: 'abc-999', env_id: 'qa',  env: 'qa'  },
];

const validationRows = [
  {
    App_id: 'abc-999',
    Environment: 'dev',
    enablementJiraStatus: 'done',
    actjiraStatus: 'pending',
  },
];

// ---- Mocks ----------------------------------------------------------------

// useNavigate
const navigateMock = jest.fn();
jest.mock('react-router-dom', () => ({
  ...(jest.requireActual('react-router-dom') as object),
  useNavigate: () => navigateMock,
}));

// API service (makeRequest)
const makeRequestMock = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
}));

// dataParsing (your code pipes all API .data through this)
jest.mock('../utils/dataParsing', () => ({
  __esModule: true,
  dataParsing: (x: unknown) => x,
}));

// Config hook (prevent pulling crypto-es)
jest.mock('../gcp_oauth/hooks/useConfApi', () => ({
  __esModule: true,
  default: () => ({ API_BASE_ENDPOINT: 'http://api.example.com' }),
}));

// Auth hook (pretend user is logged in)
jest.mock('../gcp_oauth/hooks/useAuth', () => ({
  __esModule: true,
  default: () => ({ loading: false, isAuthenticated: true }),
}));

// Context (CRITICAL: setter name is setprovisionData with lower-case p)
const setProvisionDataMock = jest.fn();
jest.mock('../ProvisionContext', () => ({
  __esModule: true,
  useProvisionContext: () => ({
    provisioningData: { githubToken: '', terraformToken: '' },
    setprovisionData: setProvisionDataMock,   // <- lower-case p
  }),
}));

// CustomNavigation — simple stub
jest.mock('../home/CustomNavigation', () => ({
  __esModule: true,
  default: () => <div data-testid="nav" />,
}));

// Dropdown — render a basic select we can change
jest.mock('../components/dropdown/Dropdown', () => ({
  __esModule: true,
  default: ({
    'data-testid': dt,
    options,
    value,
    onChange,
  }: any) => (
    <select
      data-testid={dt}
      value={value?.value ?? ''}
      onChange={(e) =>
        onChange?.({ id: 1, value: e.target.value, label: e.target.value })
      }
    >
      {(options ?? []).map((o: any) => (
        <option key={`${o.value}`} value={o.value}>
          {o.label ?? o.value}
        </option>
      ))}
    </select>
  ),
}));

// ---- Under test -----------------------------------------------------------
import ProvisionList from './provision-list';

// Helper to relax request assertions (endPoints vs endpoints)
const reqContains = (substr: string) =>
  expect.stringContaining(substr);

const jsonCallIncludes = (substr: string) =>
  (arg: any) => JSON.stringify(arg).includes(substr);

// Common render with primed API
const primeBootstrap = () => {
  makeRequestMock.mockReset();
  // 1) app/env list
  makeRequestMock.mockResolvedValueOnce({ data: projectEnvList });
  // 2) auto validation fetch for default selection
  makeRequestMock.mockResolvedValueOnce({ data: validationRows });
};

const renderPage = () => render(<ProvisionList />);

// ---- Tests ----------------------------------------------------------------

describe('ProvisionList', () => {
  test('loads project/env data, auto-fetches validation details, and renders table', async () => {
    primeBootstrap();
    renderPage();

    // Wait for the heading so we know the page mounted
    expect(await screen.findByText(/Provision List/i)).toBeInTheDocument();

    // We made the initial GET for the app/env list
    await waitFor(() => {
      // check method then search the URL flexibly
      const firstArg = makeRequestMock.mock.calls[0]?.[0];
      expect(firstArg).toEqual(expect.objectContaining({ method: 'GET' }));
      expect(JSON.stringify(firstArg)).toMatch(/provisions\/getAppIdEnvDetails/i);
    });

    // Table headers render
    expect(screen.getByText(/Application Task Validation/i)).toBeInTheDocument();
    expect(screen.getByText(/GCP Project Task Validation/i)).toBeInTheDocument();

    // And at least one row eventually appears (comes from validationRows)
    // (This also gives time for the 2nd call to resolve.)
    await screen.findByRole('button', { name: /provision/i });
  });

  test('switching project and environment triggers a fresh validation fetch', async () => {
    primeBootstrap();
    renderPage();

    // Bootstrap sends 2 calls (list + first validation)
    await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(2));

    // Prime the API for the "change" flow call
    makeRequestMock.mockResolvedValueOnce({ data: validationRows });

    // Trigger change on env dropdown
    const envSel = await screen.findByTestId('environment-dropdown');
    fireEvent.change(envSel, { target: { value: 'dev' } });

    // Should trigger one more fetch (total 3 so far)
    await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(3));
  });

  test('clicking Provision opens the token dialog when tokens are missing', async () => {
    primeBootstrap();
    renderPage();

    // Wait for row/button
    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);

    // Dialog should appear
    expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();
  });

  test('clicking Provision navigates when both tokens exist', async () => {
    primeBootstrap();

    // For this test we need tokens to exist in context.
    // Patch the context mock just for this test.
    (jest.requireMock('../ProvisionContext') as any).useProvisionContext = () => ({
      provisioningData: { githubToken: 'ghp_abc', terraformToken: 'tfp_xyz' },
      setprovisionData: setProvisionDataMock,
    });

    renderPage();

    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);

    // Navigates to /provisions/:appid/:env using the row data (abc-999/dev)
    await waitFor(() =>
      expect(navigateMock).toHaveBeenCalledWith('/provisions/abc-999/dev')
    );
  });

  test('fills tokens in dialog and submits to close the dialog path', async () => {
    primeBootstrap();
    renderPage();

    // Open dialog
    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);
    expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();

    // Type both tokens
    fireEvent.change(screen.getByLabelText(/Github Token/i), {
      target: { value: 'ghp_abc' },
    });
    fireEvent.change(screen.getByLabelText(/Terraform Token/i), {
      target: { value: 'tfp_xyz' },
    });

    // Submit
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // We at least called the context setter with merged values
    expect(setProvisionDataMock).toHaveBeenCalled();
    const last = setProvisionDataMock.mock.calls.at(-1)?.[0];
    // When using functional setter we receive a function; just ensure we passed one
    expect(typeof last === 'function' || typeof last === 'object').toBeTruthy();
  });
});
