/**
 * @file actDetails.test.tsx
 * High‑signal tests for ActDetails with lightweight mocks.
 * Drop-in replacement.
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/* ──────────────────────────────────────────────────────────────────────────
   Mocks: child libs & context
   ────────────────────────────────────────────────────────────────────────── */

// Minimal FormContext we can fully control in tests
jest.mock('../../FormContext', () => {
  const React = require('react');
  const real = jest.requireActual('../../FormContext');

  const FormContext = React.createContext({
    formData: real.initialFormData,
    setFormData: jest.fn(),
    requiredFields: [],
    resetFormData: jest.fn(),
  });

  const useFormContext = () => React.useContext(FormContext);

  return {
    __esModule: true,
    FormContext,
    useFormContext,
    // Reuse the real initial so the shape matches component expectations
    initialFormData: real.initialFormData,
  };
});

// Provide a tiny EnvContext so component can read envData
jest.mock('../../envContext', () => {
  const React = require('react');
  const EnvContext = React.createContext({ envData: { env: 'dev' } });
  const useEnv = () => React.useContext(EnvContext);
  const Provider = ({ children }: any) => (
    <EnvContext.Provider value={{ envData: { env: 'dev' } }}>
      {children}
    </EnvContext.Provider>
  );
  return { __esModule: true, EnvContext, default: Provider, useEnv };
});

// API service used for GET cloud services
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// Business service used for Save / Submit
const saveActIntake = jest.fn();
const saveGcpIntakeFinal = jest.fn();
jest.mock('../../services/gcpIntakeOnboardingService', () => ({
  __esModule: true,
  default: {
    saveActIntake: (...args: any[]) => (saveActIntake as any)(...args),
    saveGcpIntakeFinal: (...args: any[]) => (saveGcpIntakeFinal as any)(...args),
  },
}));

// DatePicker: render a simple input that calls onChange when clicked
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  DatePicker: ({ label, onChange }: any) => (
    <input
      data-testid="mock-date"
      aria-label={label}
      onClick={() => onChange('2025-01-01' as any)}
    />
  ),
}));

/* ──────────────────────────────────────────────────────────────────────────
   SUT
   ────────────────────────────────────────────────────────────────────────── */

import { FormContext, initialFormData as _realInitial } from '../../FormContext';
import ActDetails from './actDetails';

/* ──────────────────────────────────────────────────────────────────────────
   Helpers
   ────────────────────────────────────────────────────────────────────────── */

// Keep only the fields ActDetails reads/writes so no undefined access
const baseFormData = {
  ..._realInitial,
  actDetails: {
    ...(_realInitial as any).actDetails,
    summary: '',
    cloudServices: [], // rendered via Select
    appId: '',
    requesterName: '',
    requesterEmail: '',
    adGroup: '',
    vaultAdGroup: '',
    adEntServiceAccount: '',
    tfeServiceAccountRequest: '',
    targetDate: null as any,
  },
  cloudServices: [], // source list for the Select’s menu items
};

const setFormDataMock = jest.fn();

const renderWithProviders = (ui: React.ReactElement) => {
  return render(
    <FormContext.Provider
      value={{
        formData: baseFormData as any,
        setFormData: setFormDataMock,
        requiredFields: [],
        resetFormData: jest.fn(),
      }}
    >
      {ui}
    </FormContext.Provider>
  );
};

beforeEach(() => {
  jest.clearAllMocks();
  // Default GET for cloud services returns two services; one is mandatory
  makeRequest.mockResolvedValue({
    data: [
      { id: 1, label: 'Big Query', isMandatory: true },
      { id: 2, label: 'KMS', isMandatory: false },
    ],
  });
  // Default Save returns cloudServices as string to exercise normalization
  saveActIntake.mockResolvedValue({
    data: { cloudServices: 'Big Query, KMS' },
  });
  saveGcpIntakeFinal.mockResolvedValue({ data: {} });
});

/* ──────────────────────────────────────────────────────────────────────────
   Tests
   ────────────────────────────────────────────────────────────────────────── */

describe('ActDetails', () => {
  test('mount → performs GET of cloud services and renders basic fields', async () => {
    renderWithProviders(
      <ActDetails
        isAppComplete
        isComponentComplete
        intakeFormTrackingId={987}
      />
    );

    await waitFor(() => expect(makeRequest).toHaveBeenCalled());

    // Assert GET shape (loose match)
    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        responseType: 'json',
        endpoints: expect.stringMatching(/\/api\/act-details\/cloud-services/),
      })
    );

    // Two key fields should be present
    expect(screen.getByLabelText(/Summary/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/App ID/i)).toBeInTheDocument();
  });

  test('typing in Summary updates form via setFormData', async () => {
    renderWithProviders(
      <ActDetails isAppComplete isComponentComplete intakeFormTrackingId={123} />
    );

    const summary = screen.getByLabelText(/Summary/i);
    fireEvent.change(summary, { target: { name: 'summary', value: 'Hello' } });

    // setFormData is called with updater; we only assert it was called
    expect(setFormDataMock).toHaveBeenCalled();
  });

  test('date picker change calls handler (mocked) without crashing', async () => {
    renderWithProviders(
      <ActDetails isAppComplete isComponentComplete intakeFormTrackingId={123} />
    );

    // Click our stubbed date picker
    fireEvent.click(screen.getByTestId('mock-date'));
    // No explicit assertion (just ensure no errors), but the change also calls setFormData
    expect(setFormDataMock).toHaveBeenCalled();
  });

  test('Save → calls service, normalizes cloudServices string, and shows success alert', async () => {
    renderWithProviders(
      <ActDetails isAppComplete isComponentComplete intakeFormTrackingId={321} />
    );

    fireEvent.click(screen.getByRole('button', { name: /Save/i }));

    await waitFor(() => expect(saveActIntake).toHaveBeenCalled());

    // Our Save mock returns "Big Query, KMS" string; component converts to array and calls setFormData
    expect(setFormDataMock).toHaveBeenCalled();

    // Success alert should appear
    const success = await screen.findByText(/ACT details saved successfully/i);
    expect(success).toBeInTheDocument();
  });

  test('Submit → calls final service and shows submitted alert', async () => {
    renderWithProviders(
      <ActDetails isAppComplete isComponentComplete intakeFormTrackingId={444} />
    );

    fireEvent.click(screen.getByRole('button', { name: /Submit/i }));

    await waitFor(() => expect(saveGcpIntakeFinal).toHaveBeenCalledWith(444));

    const info = await screen.findByText(/Intake details submitted successfully/i);
    expect(info).toBeInTheDocument();
  });

  test('buttons are disabled when either isAppComplete or isComponentComplete is false', () => {
    renderWithProviders(
      <ActDetails isAppComplete={false} isComponentComplete={true} intakeFormTrackingId={1} />
    );

    expect(screen.getByRole('button', { name: /Save/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /Submit/i })).toBeDisabled();
  });
});
