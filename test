/**
 * @file applicationDetails.test.tsx
 *
 * Test suite for ApplicationDetails.tsx.
 * Strategy:
 *  - Mock FormContext: we DO NOT render a real Provider; we mock the hook
 *    and feed the component a stubbed context object.
 *  - Mock API hook and DatePicker.
 *  - Keep selectors resilient by using labels/text that exist in the TSX you shared.
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/* -------------------------------- Mocks ------------------------------- */

// 1) react-router-dom: component uses <Link>; we don't need full router
jest.mock('react-router-dom', () => ({
  Link: ({ children }: any) => <a>{children}</a>,
}));

// 2) DatePicker: render a simple input that triggers onChange when clicked
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  DatePicker: ({ label, onChange }: any) => (
    <input
      data-testid={`mock-date-${label}`}
      aria-label={label}
      onClick={() => onChange('2025-01-01' as any)}
      readOnly
    />
  ),
}));

// 3) LocalizationProvider & AdapterDayjs: return children as-is
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  LocalizationProvider: ({ children }: any) => <>{children}</>,
}));
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({}));

// 4) useApiService: expose a single makeRequest mock
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// 5) FormContext: we mock ONLY the hook the component calls.
type Ctx = {
  formData: any;
  setFormData: jest.Mock;
  requiredFields: string[];
  resetFormData: jest.Mock;
};
let ctxStub: Ctx = {
  formData: {},
  setFormData: jest.fn(),
  requiredFields: [],
  resetFormData: jest.fn(),
};
jest.mock('./FormContext', () => ({
  __esModule: true,
  useFormContext: () => ctxStub,
}));

/* ----------------------------- SUT import ----------------------------- */

import ApplicationDetails from './applicationDetails';

/* ------------------------------ Test data ---------------------------- */

/**
 * Minimal, safe shape: only fields the component reads/writes so no undefined access.
 * (We spread the real initial in your app; here we keep a lean version for the tests.)
 */
const baseFormData = {
  applicationDetails: {
    applicationID: '',
    applicationName: '',
    summary: '',
    description: '',
    purposeAndBenefit: '',
    lobDomain: '',
    environmentsNeeded: [] as string[],
    requesterName: '',
    requesterEmail: '',
    businessExecutiveSponsor: '',
    applicationBusinessOwner: '',
    applicationPortfolioOwner: '',
    techExecutiveSponsor: '',
    primaryTechManager: '',
    cloudAccountableExecutive: '',
    applicationArchitect: '',
    auNumber: '',
    techContact: '',
    dmiCloudContact: '',
    serviceNowSupportGroup: '',
    developersList: '',
    applicationOwnerApprover: '',
    timelineSandbox: null as any,
    timelineNonProd: null as any,
    timelineProd: null as any,
    isNewApp: 'new',
    applocation: '',
    appLinkBAM: '',
    beamsStatus: '',
    datasource: '',
    dataFormat: [] as string[],
    dataSLATime: '',
    dataClassification: '',
    panCardDataInScope: '',
    panCardDetails: '',
    sarUarData: '',
    internationalUsers: '',
    externalIngress: '',
    externalIngressDetails: '',
    serviceNowCI: '',
    technicalConstraints: '',
    reviewedWithCIO: '',
    reviewedWithArchitect: '',
    requiresCloudReview: '',
  },
  // the component also mirrors some fields into actDetails
  actDetails: {
    summary: '',
    appId: '',
    requesterName: '',
    requesterEmail: '',
  },
  artRequestDetails: [], // rendered dynamically by section, used for add/remove
};

/* -------------------------- Tiny provider shim ------------------------ */
/**
 * We donâ€™t need a real Context.Provider because the hook is mocked.
 * This wrapper just gives us a convenient place to keep the API stable in tests.
 */
const withForm = () => {
  const setFormData = jest.fn();

  ctxStub = {
    formData: JSON.parse(JSON.stringify(baseFormData)),
    setFormData,
    requiredFields: [],
    resetFormData: jest.fn(),
  };

  const Provider: React.FC<{ children: React.ReactNode }> = ({ children }) => <>{children}</>;
  return { Provider, setFormData };
};

/* ------------------------------- Helpers ------------------------------ */

const typeIn = (label: string, text: string) => {
  const el = screen.getByLabelText(label) as HTMLInputElement | HTMLTextAreaElement;
  fireEvent.change(el, { target: { name: el.getAttribute('name') || '', value: text } });
};

const clickFirstButtonNamed = (name: RegExp) => {
  const btn = screen.getAllByRole('button').find((b) =>
    new RegExp(name, 'i').test((b.textContent || '').trim())
  );
  if (!btn) throw new Error(`Button with name ${name} not found`);
  fireEvent.click(btn);
};

const openSelectByLabel = (label: string) => {
  // Click the Select's input (MUI renders it aiming at aria-label = label)
  const input = screen.getByLabelText(label);
  fireEvent.mouseDown(input);
};

/* -------------------------------- Tests ------------------------------- */

describe('ApplicationDetails (lite)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    makeRequest.mockReset();
  });

  test('renders Overview + a few core fields', () => {
    const { Provider } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // A small smoke list to be sure we mounted the right parts
    expect(screen.getByLabelText(/Application ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Application Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Summary/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Purpose and Benefit/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Environments Needed/i)).toBeInTheDocument();
  });

  test('typing in Summary updates form via setFormData (text handler)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn('Summary', 'My summary text');
    expect(setFormData).toHaveBeenCalled();
  });

  test('changing AU Number triggers number handler', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn(/AU Number/i, '12345');
    expect(setFormData).toHaveBeenCalled();
  });

  test('Environments Needed (multi-select) triggers setFormData', async () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Open the select, then pick a couple of menu items (text options exist in your TSX)
    openSelectByLabel(/Environments Needed/i);

    fireEvent.click(await screen.findByText('SIT'));
    fireEvent.click(await screen.findByText('UAT'));
    fireEvent.keyDown(document.body, { key: 'Escape' }); // close the menu

    expect(setFormData).toHaveBeenCalled();
  });

  test('date pickers call handler without crashing (Sandbox timeline)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Click mocked DatePicker input (it calls onChange with a value)
    fireEvent.click(screen.getByTestId('mock-date-Timeline for Sandbox'));
    expect(setFormData).toHaveBeenCalled();
  });

  test('typing requester email validates format (invalid -> shows helper via setValidationErrors)', () => {
    const setValidationErrors = jest.fn();
    const { Provider } = withForm();

    const SpyWrapper: React.FC = () => (
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={setValidationErrors} />
      </Provider>
    );

    render(<SpyWrapper />);
    typeIn(/Requester Email/i, 'not-an-email');

    // The component sets validation error for invalid email format; we assert setter was called
    expect(setValidationErrors).toHaveBeenCalled();
  });

  test('radio groups call handler -> data classification "public"', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Data Classification radios: Confidential/Restricted/Public exist in the file
    // Click "Public"
    fireEvent.click(screen.getByLabelText(/Public/i));
    expect(setFormData).toHaveBeenCalled();
  });

  test('search by App ID triggers both services and may open the toaster (happy path)', async () => {
    const { Provider, setFormData } = withForm();

    // 1st call: BAM details
    makeRequest
      .mockResolvedValueOnce({
        data: { applicationID: 'APP123', applicationName: 'My App' },
        status: 200,
      })
      // 2nd call: env duplication check
      .mockResolvedValueOnce({
        data: { environments: ['SIT'] },
        status: 200,
      });

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Enter App ID then click the search icon button near Application ID input
    typeIn(/Application ID/i, 'APP123');

    // There are many buttons; pick the first icon button in that row:
    const allButtons = screen.getAllByRole('button');
    fireEvent.click(allButtons[0]); // search icon's parent IconButton

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(2));
    expect(setFormData).toHaveBeenCalled(); // form patched with BAM details / envs result
  });

  test('Add "Other Field" in ART Request then remove -> setFormData called', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // "Add Other Field" button is an IconButton with Typography text
    clickFirstButtonNamed(/Add Other Field/i);
    expect(setFormData).toHaveBeenCalled();

    // Remove icon (trash/minus) is also an IconButton within the ART list.
    // Click the first remove we can see.
    const removeBtn =
      screen.getAllByRole('button').find((b) =>
        /remove/i.test((b.textContent || '').toLowerCase())
      ) || screen.getAllByRole('button')[1];

    fireEvent.click(removeBtn);
    expect(setFormData).toHaveBeenCalledTimes(2);
  });
});
