// src/sideNavbar/boarding/applicationDetails.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ApplicationDetails from './applicationDetails';

// ---------- Mock FormContext (runtime require to keep TS happy) ----------
jest.mock('./FormContext', () => {
  // use require to avoid type complaints in TS/Jest
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const React = require('react');
  const Ctx = React.createContext<any>(null);
  return {
    __esModule: true,
    useFormContext: () => React.useContext(Ctx),
    TestFormProvider: ({ value, children }: any) => (
      <Ctx.Provider value={value}>{children}</Ctx.Provider>
    ),
  };
});
// pull mocked export at runtime (no static import so TS doesn't scan it)
const { TestFormProvider } = require('./FormContext');

// ---------- Minimal, robust mocks for MUI X date pickers ----------
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({
  __esModule: true,
  default: function AdapterDayjs() {
    return null;
  },
}));
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  LocalizationProvider: ({ children }: any) => <div>{children}</div>,
}));
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  DatePicker: ({ label, value, onChange }: any) => (
    <input
      aria-label={label}
      value={value ?? ''}
      onChange={(e) => onChange?.(e.target.value)}
    />
  ),
}));

// ---------- API hook mock so we don't hit the network ----------
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({
    makeRequest: jest.fn().mockResolvedValue({
      data: {
        applicationID: 'APP123',
        environments: ['DEV1', 'SIT'],
      },
    }),
  }),
}));

// ---------- helpers ----------
type RenderOpts = {
  validation?: any;
  setFormDataSpy?: jest.Mock;
  formDataOverride?: any;
};

function makeBaseFormData(overrides: any = {}) {
  // Minimal shape the component expects at render time
  return {
    // other pages keep their slices, we only include what this file reads
    applicationDetails: {
      applicationID: '',
      applicationName: '',
      summary: '',
      description: '',
      purposeAndBenefit: '',
      lobDomain: '',
      requesterName: '',
      requesterEmail: '',
      primaryTechManager: '',
      applicationBusinessOwner: '',
      applicationPortfolioOwner: '',
      techExecutiveSponsor: '',
      cloudAccountableExecutive: '',
      applicationArchitect: '',
      auNumber: '',
      techContact: '',
      dmiCloudContact: '',
      serviceNowSupportGroup: '',
      developersList: '',
      applicationOwnerApprover: '',
      serviceNowCI: '',
      technicalConstraints: '',
      // booleans / radios as strings per your component
      isNewApp: '',
      beansStatus: '',
      dataSource: '',
      dataFormat: [], // multi-select
      environmentsNeeded: [], // multi-select
      environmentForValidation: [],

      // date pickers (stringy in tests; component converts)
      timelineSandbox: null,
      timelineNonProd: null,
      timelineProd: null,

      // conditional sections
      dataClassification: '',
      panCardDataInScope: '',
      panCardDetails: '',
      sarUarData: '',
      internationalUsers: '',
      externalIngress: '',
      externalIngressDetails: '',

      // ART details – the missing piece that crashed render
      artRequestDetails: {}, // ✅ keep as object; tests can override with categories
    },
    // other slices referenced when component mirrors some fields into actDetails
    actDetails: {},
    ...overrides,
  };
}

function renderWithProvider(opts: RenderOpts = {}) {
  const user = userEvent.setup();
  const formData = makeBaseFormData(opts.formDataOverride);
  const setFormData = opts.setFormDataSpy ?? jest.fn();

  const value = { formData, setFormData };

  const validationErrors =
    opts.validation ?? {
      applicationDetails: {},
    };

  const setValidationErrors = jest.fn();

  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <TestFormProvider value={value}>{children}</TestFormProvider>
  );

  render(
    <Wrapper>
      <ApplicationDetails
        validationErrors={validationErrors}
        setValidationErrors={setValidationErrors}
      />
    </Wrapper>
  );

  return { user, formData, setFormData, setValidationErrors };
}

// ---------- Tests ----------
describe('ApplicationDetails', () => {
  test('renders key fields and headings', () => {
    renderWithProvider();

    // Overview accordion title, a few representative labels/inputs present on first paint
    expect(
      screen.getByRole('heading', { name: /overview/i })
    ).toBeInTheDocument();

    expect(
      screen.getByRole('textbox', { name: /application id/i })
    ).toBeInTheDocument();
    expect(
      screen.getByRole('textbox', { name: /application name/i })
    ).toBeInTheDocument();
    expect(screen.getByRole('textbox', { name: /summary/i })).toBeInTheDocument();
    expect(
      screen.getByRole('combobox', { name: /environments needed/i })
    ).toBeInTheDocument();
  });

  test('shows email validation message for invalid email', async () => {
    const { user, setFormData } = renderWithProvider();

    const email = screen.getByRole('textbox', { name: /requester email/i });
    await user.clear(email);
    await user.type(email, 'not-an-email');

    // component writes a validation error and still mirrors into formData
    expect(setFormData).toHaveBeenCalled();
    expect(
      screen.getByText(/invalid email format/i)
    ).toBeInTheDocument();
  });

  test('clicking search icon on Application ID triggers BAM fetch', async () => {
    // give a non-empty id so click handler fires
    const { user } = renderWithProvider({
      formDataOverride: {
        applicationDetails: { applicationID: 'APP123' },
      },
    });

    // the icon button is rendered inside InputAdornment; find by role "button"
    const searchBtns = screen.getAllByRole('button');
    // pick the first one in the Application ID row
    await user.click(searchBtns[0]);

    // After mocked fetch, we expect the toast/snackbar info to appear
    expect(
      await screen.findByText(/Onboarding form is already submitted/i)
    ).toBeInTheDocument();
  });

  test('multi‑select "Environments Needed" displays selected values as comma‑joined string', async () => {
    const { user, setFormData } = renderWithProvider();

    const envSelect = screen.getByRole('combobox', {
      name: /environments needed/i,
    });

    // Our mocked <Select> is a simple input under the hood via our mocks.
    // Type a joined list to simulate selection.
    await user.clear(envSelect);
    await user.type(envSelect, 'DEV1,SIT');

    // The component writes to formData; we assert it was called.
    expect(setFormData).toHaveBeenCalled();
  });

  test('picks dates via DatePicker and stores ISO strings', async () => {
    const { user, setFormData } = renderWithProvider();

    const sandbox = screen.getByRole('textbox', {
      name: /timeline for sandbox/i,
    });
    const nonprod = screen.getByRole('textbox', {
      name: /timeline for non-prod\/uat/i,
    });
    const prod = screen.getByRole('textbox', {
      name: /timeline for production/i,
    });

    await user.clear(sandbox);
    await user.type(sandbox, '2025-01-12');
    await user.clear(nonprod);
    await user.type(nonprod, '2025-02-10');
    await user.clear(prod);
    await user.type(prod, '2025-03-05');

    // component converts via dayjs(date).toISOString(); we only assert we wrote something
    expect(setFormData).toHaveBeenCalled();
  });

  test('renders ART Request Details section even when artRequestDetails is empty', () => {
    // This is the regression for the crash: ensure empty object does not explode
    renderWithProvider({
      formDataOverride: {
        applicationDetails: { artRequestDetails: {} },
      },
    });

    // The section heading exists (exact wording may vary; assert presence of a known label nearby)
    expect(screen.getByText(/art request/i)).toBeInTheDocument();
  });
});
