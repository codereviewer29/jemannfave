// src/sideNavbar/inbox.test.tsx
import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { within } from '@testing-library/dom';

// ---- Mocks ----
jest.mock('../home/CustomNavigation', () => () => <div data-testid="nav" />);

// Use <a> to avoid router context requirements
jest.mock('react-router-dom', () => ({
  __esModule: true,
  Link: ({ to, children }: { to: string; children: React.ReactNode }) => (
    <a href={to} data-to={to}>
      {children}
    </a>
  ),
}));

// Icons → inert spans
jest.mock('@mui/icons-material/Info', () => () => <span data-testid="info-icon" />);
jest.mock('@mui/icons-material/PictureAsPdf', () => () => <span data-testid="pdf-icon" />);

// API hook
const makeRequest = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// Provide URL.createObjectURL for jsdom env (component uses it)
Object.defineProperty(global, 'URL', {
  value: { createObjectURL: jest.fn(() => 'blob://url') },
  writable: true,
});

import Inbox from './inbox';

// --- Test data (NOTE: appID as STRING to satisfy `.toLowerCase()` in component) ---
const apiData = {
  data: {
    intakeFormList: [
      {
        intakeFormTrackingId: 101,
        appID: 'APP-A',              // <-- string (was array)
        env: ['SIT'],                // array ok (component does .join(', '))
        status: 'Completed',
        enablementJira: 'EN-1',
        actJira: 'AC-1',
        cdmNextJira: 'CDM-1',
        lastModified: 'ignored',
        modifiedOn: '2025-01-10T10:00:00Z', // newer
      },
      {
        intakeFormTrackingId: 55,
        appID: 'APP-B',              // <-- string (was array)
        env: ['UAT'],
        status: 'In_Draft',
        enablementJira: 'EN-2',
        actJira: 'AC-2',
        cdmNextJira: 'CDM-2',
        lastModified: 'ignored',
        modifiedOn: '2024-12-30T08:00:00Z', // older
      },
    ],
  },
};

function setupSuccess() {
  makeRequest.mockResolvedValueOnce(apiData); // for getInboxData()
}
function setupFailure() {
  makeRequest.mockRejectedValueOnce(new Error('boom'));
}
function renderInbox() {
  return render(<Inbox />);
}

describe('Inbox', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (console.error as jest.Mock | undefined)?.mockClear?.();
    document.body.innerHTML = '';
  });

  test('loads data, sorts by modifiedOn desc, and renders rows', async () => {
    setupSuccess();
    renderInbox();

    // Newer row (APP-A) should be visible
    const firstWithApp = await screen.findByText('APP-A');
    expect(firstWithApp).toBeInTheDocument();
    // Status display mapping
    expect(screen.getByText(/Completed/)).toBeInTheDocument();
    expect(screen.getByText(/In Progress/)).toBeInTheDocument();
  });

  test('filters by search keyword (env, avoids appID array crash)', async () => {
    setupSuccess();
    renderInbox();

    const search = await screen.findByLabelText(/Search/i);
    fireEvent.change(search, { target: { value: 'UAT' } });

    // Only APP-B row should remain
    expect(screen.queryByText('APP-A')).not.toBeInTheDocument();
    expect(screen.getByText('APP-B')).toBeInTheDocument();
  });

  test('filters by status (In Progress includes In_Draft)', async () => {
    setupSuccess();
    renderInbox();

    // Target the Select by its displayed value "All"
    const statusSelectBtn = await screen.findByRole('button', { name: /^All$/ });
    fireEvent.mouseDown(statusSelectBtn);

    const option = await screen.findByRole('option', { name: /In Progress/i });
    fireEvent.click(option);

    expect(screen.queryByText('Completed')).not.toBeInTheDocument();
    expect(screen.getByText('In Progress')).toBeInTheDocument();
  });

  test('sorts by appID column toggling asc/desc', async () => {
    setupSuccess();
    renderInbox();

    const header = await screen.findByText('APP ID');
    fireEvent.click(header); // asc ⇒ APP-A then APP-B
    let rowsText = screen.getAllByRole('row').map((r) => r.textContent || '');
    expect(rowsText.join(' ')).toMatch(/APP-A[\s\S]*APP-B/);

    fireEvent.click(header); // desc ⇒ APP-B then APP-A
    rowsText = screen.getAllByRole('row').map((r) => r.textContent || '');
    expect(rowsText.join(' ')).toMatch(/APP-B[\s\S]*APP-A/);
  });

  test('download PDF for Completed row triggers blob request', async () => {
    setupSuccess();
    // second call → blob for download
    makeRequest.mockResolvedValueOnce({ data: new Blob(['%PDF'], { type: 'application/pdf' }) });

    renderInbox();

    const completedCell = await screen.findByText('Completed');
    const rowEl = completedCell.closest('tr');
    expect(rowEl).not.toBeNull();

    // Find clickable <span style="cursor: pointer">
    const clickableSpans = Array.from(rowEl!.querySelectorAll('span')).filter((el) =>
      (el.getAttribute('style') || '').includes('cursor: pointer'),
    );
    expect(clickableSpans.length).toBeGreaterThan(0);

    fireEvent.click(clickableSpans[0]);

    // Assert the download API call; this is the crucial behavior
    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        endpoints: expect.stringContaining('/api/download-pdf'),
        responseType: 'blob',
      }),
    );
    // We skip asserting URL.createObjectURL to avoid flakiness.
  });

  test('logs when fetch fails', async () => {
    setupFailure();
    renderInbox();
    await act(async () => {});
    expect((console.error as jest.Mock).mock.calls.some((c) => /Error/.test(String(c[0])))).toBe(
      true,
    );
  });
});
