// src/services/useApiService.test.tsx
import React from 'react';
import { renderHook, act } from '@testing-library/react';
import useApiService from './useApiService';

// ---- Mocks ----
const processHttpRequestMock = jest.fn();
jest.mock('./processHttp', () => ({
  __esModule: true,
  default: (...args: any[]) => processHttpRequestMock(...args),
  // if you export named too, also: processHttpRequest: (...args) => processHttpRequestMock(...args),
}));

const useAppGlobalStateMock = jest.fn();
const useConfigMock = jest.fn();

jest.mock('@wf/react-library', () => ({
  __esModule: true,
  useAppGlobalState: () => useAppGlobalStateMock(),
  useConfig: () => useConfigMock(),
}));

type HttpRequest = {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  endpoint: string;
  body?: unknown;
  headers?: Record<string, string>;
};

describe('useApiService', () => {
  const BASE = 'https://api.example.test';
  const TOKEN = { access_token: 'abc123' };

  beforeEach(() => {
    jest.clearAllMocks();
    useConfigMock.mockReturnValue({ API_BASE_ENDPOINT: BASE });
  });

  test('calls processHttpRequest with (request, access_token, baseEndpoint)', async () => {
    useAppGlobalStateMock.mockReturnValue(TOKEN);
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req: HttpRequest = { method: 'GET', endpoint: '/things' };

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledTimes(1);
    expect(processHttpRequestMock).toHaveBeenCalledWith(req, TOKEN.access_token, BASE);
  });

  test('passes undefined token when global state does not have one', async () => {
    useAppGlobalStateMock.mockReturnValue(undefined);
    processHttpRequestMock.mockResolvedValue({ ok: true });

    const { result } = renderHook(() => useApiService());
    const req: HttpRequest = { method: 'POST', endpoint: '/items', body: { a: 1 } };

    await act(async () => {
      await result.current.makeRequest(req);
    });

    expect(processHttpRequestMock).toHaveBeenCalledWith(req, undefined, BASE);
  });

  test('returns the resolved value from processHttpRequest', async () => {
    useAppGlobalStateMock.mockReturnValue(TOKEN);
    const payload = { id: 7, name: 'thing' };
    processHttpRequestMock.mockResolvedValue(payload);

    const { result } = renderHook(() => useApiService());
    const req: HttpRequest = { method: 'GET', endpoint: '/thing/7' };

    const out = await act(async () => result.current.makeRequest(req));

    // act() returns whatever the callback returns; for clarity, reâ€‘await directly:
    const value = await result.current.makeRequest(req);
    expect(value).toBe(payload);
  });

  test('propagates errors from processHttpRequest', async () => {
    useAppGlobalStateMock.mockReturnValue(TOKEN);
    const err = new Error('network down');
    processHttpRequestMock.mockRejectedValue(err);

    const { result } = renderHook(() => useApiService());
    const req: HttpRequest = { method: 'GET', endpoint: '/oops' };

    await expect(result.current.makeRequest(req)).rejects.toThrow('network down');
  });
});
