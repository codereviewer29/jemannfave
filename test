// src/sideNavbar/boarding/intake-components/cancelOnboarding.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// ---- Minimal MUI stubs (why: keep tests fast & deterministic) ----
jest.mock('@mui/material', () => {
  const React = require('react');

  const Dialog = ({ open, onClose, children }: any) => (
    <div data-testid="dialog">{open ? (
      <div>
        {children}
        {/* expose close control to trigger onClose from tests */}
        <button aria-label="close-dialog" onClick={() => onClose?.({}, 'backdropClick')} />
      </div>
    ) : null}</div>
  );
  const DialogTitle = ({ children }: any) => <h2>{children}</h2>;
  const DialogContent = ({ children }: any) => <div>{children}</div>;
  const DialogContentText = ({ children }: any) => <p>{children}</p>;
  const DialogActions = ({ children }: any) => <div>{children}</div>;
  const Button = ({ children, onClick, ...rest }: any) => (
    <button onClick={onClick} {...rest}>{children}</button>
  );

  return {
    __esModule: true,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Button,
  };
});

// ---- SUT ----
import CancelOnboarding from './cancelOnboarding';

describe('CancelOnboarding', () => {
  test('renders title, message, and action buttons when open', () => {
    const onClose = jest.fn();
    const onConfirm = jest.fn();

    render(
      <CancelOnboarding
        openCancelDialog={true}
        handleCloseCancelDialog={onClose}
        handleConfirmCancel={onConfirm}
      />
    );

    expect(screen.getByRole('heading', { name: /confirm cancellation/i })).toBeInTheDocument();
    expect(
      screen.getByText(/are you sure you want to cancel\? any unsaved changes will be lost\./i)
    ).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /^no$/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /^yes$/i })).toBeInTheDocument();
  });

  test('clicking "No" calls handleCloseCancelDialog', async () => {
    const onClose = jest.fn();
    const onConfirm = jest.fn();
    const user = userEvent.setup();

    render(
      <CancelOnboarding
        openCancelDialog={true}
        handleCloseCancelDialog={onClose}
        handleConfirmCancel={onConfirm}
      />
    );

    await user.click(screen.getByRole('button', { name: /^no$/i }));
    expect(onClose).toHaveBeenCalledTimes(1);
    expect(onConfirm).not.toHaveBeenCalled();
  });

  test('clicking "Yes" calls handleConfirmCancel', async () => {
    const onClose = jest.fn();
    const onConfirm = jest.fn();
    const user = userEvent.setup();

    render(
      <CancelOnboarding
        openCancelDialog={true}
        handleCloseCancelDialog={onClose}
        handleConfirmCancel={onConfirm}
      />
    );

    await user.click(screen.getByRole('button', { name: /^yes$/i }));
    expect(onConfirm).toHaveBeenCalledTimes(1);
  });

  test('does not render content when closed', () => {
    const onClose = jest.fn();
    const onConfirm = jest.fn();

    render(
      <CancelOnboarding
        openCancelDialog={false}
        handleCloseCancelDialog={onClose}
        handleConfirmCancel={onConfirm}
      />
    );

    expect(screen.queryByRole('heading', { name: /confirm cancellation/i })).not.toBeInTheDocument();
  });

  test('closing via dialog onClose triggers handleCloseCancelDialog', async () => {
    const onClose = jest.fn();
    const user = userEvent.setup();

    render(
      <CancelOnboarding
        openCancelDialog={true}
        handleCloseCancelDialog={onClose}
        handleConfirmCancel={jest.fn()}
      />
    );

    await user.click(screen.getByRole('button', { name: /close-dialog/i }));
    expect(onClose).toHaveBeenCalledTimes(1);
  });
});
