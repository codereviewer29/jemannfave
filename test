// helper stays the same
type Env = 'UAT' | 'SIT' | 'Sandbox';
const getEnvKeys = (env: Env) => {
  switch (env) {
    case 'SIT':     return { nameKey: 'sitvenafiFileName',     contentKey: 'sitvenafiFileContent' };
    case 'UAT':     return { nameKey: 'uatvenafiFileName',     contentKey: 'uatvenafiFileContent' };
    case 'Sandbox': return { nameKey: 'sandboxvenafiFileName', contentKey: 'sandboxvenafiFileContent' };
  }
};
const hasFileForEnv = (env: Env) => {
  const { nameKey } = getEnvKeys(env);
  return Boolean((formData?.cdnNextDetails as any)?.[nameKey]);
};

// ONLY ONE ENV PER CLICK
const handleUploadChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
  const files = event.target.files;
  const file = files && files[0];
  if (!file) return;

  // pick the first selected env that doesn't already have a file
  const target = selectedEnvironments.find((env) => !hasFileForEnv(env)) as Env | undefined;

  // nothing to do (all selected envs already have files)
  if (!target) {
    // optional: toast "A file is already uploaded for all selected environments. Delete first to replace."
    if (fileInputRef.current) fileInputRef.current.value = '';
    return;
  }

  // set only the target env to pending
  setVenafiStatus((s) => ({ ...s, [target]: 'pending' }));

  // build FormData and call your API (no Content-Type header!)
  const venafiData = new FormData();
  venafiData.append('certificate_file', file);

  const httpRequest = {
    method: 'POST' as const,
    endpoints: '/upload-venafi-certificate/',
    responseType: 'json' as const,
    headers: {},               // <- leave empty; fetch will set multipart boundary
    body: venafiData,
  };

  try {
    const response = (await makeRequest(httpRequest)) as any;

    if (response?.data?.status === 'Success') {
      // use backend filename if provided, otherwise fall back to picked name
      const serverName =
        response?.data?.sitfilename ||
        response?.data?.uatfilename ||
        response?.data?.sandboxfilename ||
        file.name;

      const serverContent =
        response?.data?.sitfilecontent ||
        response?.data?.uatfilecontent ||
        response?.data?.sandboxfilecontent ||
        '';

      // write only to the ONE target env
      setFormData((prev) => {
        const next: any = { ...prev, cdnNextDetails: { ...prev.cdnNextDetails } };
        const { nameKey, contentKey } = getEnvKeys(target);
        next.cdnNextDetails[nameKey] = serverName;
        next.cdnNextDetails[contentKey] = serverContent;
        return next;
      });

      setVenafiStatus((s) => ({ ...s, [target]: 'success' }));
    } else {
      setVenafiStatus((s) => ({ ...s, [target]: 'error' }));
    }
  } catch (_) {
    setVenafiStatus((s) => ({ ...s, [target]: 'error' }));
  } finally {
    if (fileInputRef.current) fileInputRef.current.value = '';
  }
};
