/**
 * applicationDetails.test.tsx
 * - Router mocks added so Link/useHref don't require a real Router
 * - Same lightweight testing pattern as earlier suites
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/* ----------------------------- Router Mocks ------------------------------ */
// Avoid "Cannot destructure 'basename' ..." by stubbing react-router-dom
const navigateMock = jest.fn();
const paramsMock: Record<string, string> = {};

jest.mock('react-router-dom', () => ({
  __esModule: true,
  useNavigate: () => navigateMock,
  useParams: () => paramsMock,
  // a dumb Link that doesn't touch Router context / useHref
  Link: ({ to, children }: { to?: string; children?: React.ReactNode }) => (
    <a href={typeof to === 'string' ? to : '#'}>{children}</a>
  ),
}));

/* ------------------------------ Service Mocks ---------------------------- */
// light wrapper used by component to GET/POST
const makeRequest = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// external service used by ActDetails previously; SUT may not call these,
// but keep pattern consistent to avoid import crashes if referenced.
const saveActIntake = jest.fn();
const saveGcpIntakeFinal = jest.fn();
jest.mock('../services/gcpIntakeOnboardingService', () => ({
  __esModule: true,
  default: {
    saveACTIntake: (...args: any[]) => saveActIntake(...args),
    saveGcpIntakeFinal: (...args: any[]) => saveGcpIntakeFinal(...args),
  },
}));

/* ------------------------------ DatePicker Mock -------------------------- */
// MUI DatePicker stand‑in: renders an input that triggers onChange when clicked
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  DatePicker: ({ label, onChange }: any) => (
    <input
      data-testid="mock-date"
      aria-label={label}
      onClick={() => onChange?.('2025-01-01' as any)}
      readOnly
    />
  ),
}));
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  LocalizationProvider: ({ children }: any) => <>{children}</>,
}));
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({
  __esModule: true,
  default: function AdapterDayjs() {},
}));

/* ------------------------------ Form Context ----------------------------- */
import { FormContext, initialFormData as realInitial } from '../FormContext';

/** Minimal, safe shape for this suite (only fields the component reads/writes).
 *  We spread the real initial so nested objects exist with correct keys.
 */
const baseFormData = {
  ...realInitial,
  applicationDetails: {
    ...(realInitial as any).applicationDetails,
    applicationID: '',
    applicationName: '',
    summary: '',
    description: '',
    purposeAndBenefit: '',
    lobDomain: '',
    environmentsNeeded: [],
    requesterName: '',
    requesterEmail: '',
    businessExecutiveSponsor: '',
    applicationBusinessOwner: '',
    applicationPortfolioOwner: '',
    techExecutiveSponsor: '',
    primaryTechManager: '',
    cloudAccountableExecutive: '',
    applicationArchitect: '',
    auNumber: '',
    techContact: '',
    dmiCloudContact: '',
    serviceNowSupportGroup: '',
    applicationOwnerApprover: '',
    timelineSandbox: null,
    timelineNonProd: null,
    timelineProd: null,
    datasource: '',
    dataFormat: [],
    dataSLATime: '',
    dataClassification: 'public',
    panCardDataInScope: '',
    panCardDetails: '',
    sarUarData: '',
    internationalUsers: '',
    externalIngress: '',
    externalIngressDetails: '',
    serviceNowCI: '',
    technicalConstraints: '',
    reviewedWithCIO: '',
    reviewedWithArchitect: '',
    requiresCloudReview: '',
  },
} as any;

const withForm = () => {
  const setFormData = jest.fn();
  const Provider = ({ children }: { children: React.ReactNode }) => (
    <FormContext.Provider
      value={{
        formData: baseFormData,
        setFormData,
        requiredFields: [],
        resetFormData: jest.fn(),
      }}
    >
      {children}
    </FormContext.Provider>
  );
  return { Provider, setFormData };
};

/* ----------------------------------- SUT --------------------------------- */
import ApplicationDetails from './applicationDetails';

/* --------------------------------- Helpers -------------------------------- */
const typeIn = (label: string, text: string) => {
  const el = screen.getByLabelText(label) as HTMLInputElement | HTMLTextAreaElement;
  fireEvent.change(el, { target: { name: el.getAttribute('name') || '', value: text } });
};

const clickFirstButtonNamed = (name: RegExp) => {
  const btn = screen.getAllByRole('button', { name })[0];
  fireEvent.click(btn);
};

/* --------------------------------- Tests ---------------------------------- */

beforeEach(() => {
  jest.clearAllMocks();
});

describe('ApplicationDetails (lite)', () => {
  test('renders Overview + a few core fields', () => {
    const { Provider } = withForm();
    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // a couple of always-present fields
    expect(screen.getByLabelText(/Application ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Application Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/^Summary$/i)).toBeInTheDocument();
  });

  test('changing Summary and AU Number updates via setFormData', () => {
    const { Provider, setFormData } = withForm();
    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn('Summary', 'hello world');
    typeIn(/AU Number/i, 'AU-123');

    // component uses setFormData updater; only assert it was invoked
    expect(setFormData).toHaveBeenCalled();
  });

  test('Environments Needed (multi-select) updates form via setFormData', async () => {
    const { Provider, setFormData } = withForm();
    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // open the select by clicking its label
    fireEvent.mouseDown(screen.getByLabelText(/Environments Needed/i));
    // tick first available option (Sandbox)
    fireEvent.click(screen.getByText(/Sandbox/i));

    expect(setFormData).toHaveBeenCalled();
  });

  test('date pickers call handler without crashing (Sandbox timeline)', async () => {
    const { Provider, setFormData } = withForm();
    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // our mocked DatePicker triggers onChange on click
    fireEvent.click(screen.getAllByTestId('mock-date')[0]); // one of the date pickers
    expect(setFormData).toHaveBeenCalled();
  });

  test('typing requester email validates format (invalid → shows helper via setValidationErrors)', async () => {
    const setValidationErrors = jest.fn();
    const { Provider } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={setValidationErrors} />
      </Provider>
    );

    typeIn(/Requester Email/i, 'not-an-email');

    await waitFor(() =>
      expect(setValidationErrors).toHaveBeenCalledWith(
        expect.objectContaining({
          applicationDetails: expect.objectContaining({
            requesterEmail: expect.stringMatching(/invalid email/i),
          }),
        })
      )
    );
  });

  test('radio groups call handler → data classification "public"', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // classification radios are rendered with labels
    fireEvent.click(screen.getByLabelText(/Public/i));
    expect(setFormData).toHaveBeenCalled();
  });

  test('search by App ID triggers both services (BAM + env validation) and may open toaster (happy path)', async () => {
    const { Provider } = withForm();

    // 1st GET: BAM details for app id
    makeRequest
      .mockResolvedValueOnce({
        data: { applicationID: 'APP123', applicationName: 'My App' },
        status: 200,
      })
      // 2nd GET: env duplication check
      .mockResolvedValueOnce({
        data: { environments: ['SIT'] },
        status: 200,
      });

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // fill application id and click the search icon button at the end adornment
    typeIn(/Application ID/i, 'APP123');

    // find the magnifier icon's parent button (there are many buttons)
    const icon = screen.getByTestId('icon-search');
    const btn = icon.closest('button') || screen.getAllByRole('button')[0];
    fireEvent.click(btn);

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(2));
  });

  test('Add "Other Field" in ART Request then remove → setFormData called', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // There is an "Add Other Field" button near ART section
    fireEvent.click(screen.getByRole('button', { name: /add other field/i }));
    expect(setFormData).toHaveBeenCalled();

    // remove icon (trash/minus) – click the first remove we can find
    const removeBtns = screen.getAllByRole('button').filter((b) =>
      /remove/i.test((b.getAttribute('aria-label') || b.textContent || '').toLowerCase())
    );
    if (removeBtns[0]) fireEvent.click(removeBtns[0]);

    expect(setFormData).toHaveBeenCalled();
  });
});
