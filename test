// src/intake-components/__tests__/CDPIntakeForm.test.tsx
import React from 'react';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  Form: ({ children, onSubmit }: { children: React.ReactNode; onSubmit?: React.FormEventHandler }) => (
    <form onSubmit={onSubmit}>{children}</form>
  ),
}));

jest.mock('@mui/material', () => {
  const actual = jest.requireActual('@mui/material');
  return {
    ...actual,
    Tooltip: ({ title, children }: { title: React.ReactNode; children: React.ReactElement }) => (
      <div>
        <div data-testid="tooltip-title">{title}</div>
        {children}
      </div>
    ),
  };
});

let ctxFormData: any;
let ctxSetFormData: jest.Mock;
let ctxSetReadOnly: jest.Mock;

jest.mock('../FormContext', () => ({
  useFormContext: () => ({
    formData: ctxFormData,
    setFormData: ctxSetFormData,
    setReadOnly: ctxSetReadOnly,
  }),
}));

import CDPIntakeForm from '../cdpIntakeForm';

function resetCtx(overrides?: Partial<any>) {
  ctxFormData = {
    cdpDetails: { versionCDPRequired: '' },
    safeRoomDetails: { dataLoadRequired: '' },
    ...(overrides ?? {}),
  };
  ctxSetFormData = jest.fn((next: any) => {
    ctxFormData = typeof next === 'function' ? next(ctxFormData) : next;
  });
  ctxSetReadOnly = jest.fn();
}

function renderForm(validationErrors: Record<string, boolean> = {}) {
  return render(<CDPIntakeForm validationErrors={validationErrors} />);
}

describe('CDPIntakeForm', () => {
  beforeEach(() => resetCtx());

  test('renders headings, label, tooltip, and disabled Select', () => {
    const { container } = renderForm();

    expect(screen.getByText(/CDP Overview/i)).toBeInTheDocument();
    expect(
      screen.getByText(/Cloud Data pipeline \(CDP\) Framework streamlines and accelerates Cloud migration/i)
    ).toBeInTheDocument();

    const select = screen.getByRole('combobox', {
      name: /Which version of CDP is required/i,
    });
    expect(select).toBeDisabled();

    const tip = screen.getByTestId('tooltip-title');
    expect(within(tip).getByText(/Cloud Storage: Both inbound and outbound/i)).toBeInTheDocument();
    expect(within(tip).getByText(/Big Query: Inbound data is handled/i)).toBeInTheDocument();

    expect(container).toMatchSnapshot();
  });

  test('useEffect maps Cloud Storage → File to BQ version', () => {
    resetCtx({ safeRoomDetails: { dataLoadRequired: 'Cloud Storage' } });
    renderForm();
    expect(ctxFormData.cdpDetails.versionCDPRequired).toBe('File to BQ version');
  });

  test('useEffect maps Big Query → BQ to BQ version', () => {
    resetCtx({ safeRoomDetails: { dataLoadRequired: 'Big Query' } });
    renderForm();
    expect(ctxFormData.cdpDetails.versionCDPRequired).toBe('BQ to BQ version');
  });

  test('handleChange updates context', async () => {
    const user = userEvent.setup();
    renderForm();

    // Since select is disabled, we simulate direct call by changing manually
    const select = screen.getByRole('combobox', {
      name: /Which version of CDP is required/i,
    });
    expect(select).toBeDisabled();

    // call change handler via typing
    await user.type(select, 'BQ to BQ version');
    expect(ctxSetFormData).toHaveBeenCalled();
  });

  test('Save success path shows alert and disables buttons', async () => {
    const user = userEvent.setup();
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

    resetCtx({ cdpDetails: { versionCDPRequired: 'File to BQ version' } });
    renderForm();

    await user.click(screen.getByRole('button', { name: /^Save$/i }));

    expect(screen.getByText(/Saferoom Intake details saved Successfully/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /^Save$/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /Cancel/i })).toBeDisabled();
    expect(logSpy).toHaveBeenCalled();
    logSpy.mockRestore();
  });

  test('Save with missing field shows validation error', async () => {
    const user = userEvent.setup();
    renderForm();

    await user.click(screen.getByRole('button', { name: /^Save$/i }));
    expect(screen.getByText(/Please complete all required fields before saving/i)).toBeInTheDocument();
  });

  test('validationErrors prop marks Select invalid', () => {
    renderForm({ versionCDPRequired: true });

    const select = screen.getByRole('combobox', {
      name: /Which version of CDP is required/i,
    });
    expect(select).toHaveAttribute('aria-invalid', 'true');
  });

  test('Cancel logs message', async () => {
    const user = userEvent.setup();
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    renderForm();

    await user.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(logSpy).toHaveBeenCalledWith('Form cancelled');
    logSpy.mockRestore();
  });
});
