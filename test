import { renderHook, act } from '@testing-library/react';
import useApiService from './useApiService';
import type { HttpRequest } from './types';

/* -------------------- Mocks -------------------- */

// @wf/react-library: only the hooks we use
jest.mock('@wf/react-library', () => ({
  useAppGlobalState: jest.fn(),
  useConfig: jest.fn(),
}));
const useAppGlobalStateMock = jest.requireMock('@wf/react-library')
  .useAppGlobalState as jest.Mock;
const useConfigMock = jest.requireMock('@wf/react-library')
  .useConfig as jest.Mock;

// processHttp: named export processHttpRequest
jest.mock('./processHttp', () => ({
  processHttpRequest: jest.fn(),
}));
const processHttpRequestMock = jest.requireMock('./processHttp')
  .processHttpRequest as jest.Mock;

/* -------------------- Helpers -------------------- */

// Build a fully-typed HttpRequest with sensible defaults.
// NOTE: Your appâ€™s type requires `endpoints` and `responseType`.
const makeReq = (overrides: Partial<HttpRequest> = {}): HttpRequest => ({
  method: 'GET',
  endpoints: '/things',
  // keep this for any legacy reads in code/tests (harmless if unused)
  // @ts-expect-error retain single 'endpoint' for compatibility
  endpoint: '/things',
  responseType: 'json',
  ...overrides,
});

const TOKEN = { access_token: 'abc123' };
const BASE = 'BASE';

beforeEach(() => {
  jest.clearAllMocks();
  // default env
  useConfigMock.mockReturnValue({ API_BASE_ENDPOINT: BASE });
});

/* -------------------- Tests -------------------- */

test('calls processHttpRequest with (request, access_token, baseEndpoint)', async () => {
  useAppGlobalStateMock.mockReturnValue(TOKEN);
  processHttpRequestMock.mockResolvedValue({ ok: true });

  const { result } = renderHook(() => useApiService());
  const req = makeReq({ endpoints: '/things' });

  await act(async () => {
    await result.current.makeRequest(req);
  });

  expect(processHttpRequestMock).toHaveBeenCalledTimes(1);
  expect(processHttpRequestMock).toHaveBeenCalledWith(req, TOKEN.access_token, BASE);
});

test('passes undefined token when global state does not have one', async () => {
  useAppGlobalStateMock.mockReturnValue(undefined);
  processHttpRequestMock.mockResolvedValue({ ok: true });

  const { result } = renderHook(() => useApiService());
  const req = makeReq();

  await act(async () => {
    await result.current.makeRequest(req);
  });

  expect(processHttpRequestMock).toHaveBeenCalledWith(req, undefined, BASE);
});

test('returns the resolved value from processHttpRequest', async () => {
  useAppGlobalStateMock.mockReturnValue(TOKEN);
  const payload = { id: 7, name: 'thing' };
  processHttpRequestMock.mockResolvedValue(payload);

  const { result } = renderHook(() => useApiService());
  const req = makeReq({ endpoints: '/thing/7' });

  // act returns whatever the callback returns; await directly for clarity
  const value = await act(async () => result.current.makeRequest(req));

  expect(value).toBe(payload);
});

test('propagates errors from processHttpRequest', async () => {
  useAppGlobalStateMock.mockReturnValue(TOKEN);
  const err = new Error('network down');
  processHttpRequestMock.mockRejectedValue(err);

  const { result } = renderHook(() => useApiService());
  const req = makeReq({ endpoints: '/oops' });

  await expect(result.current.makeRequest(req)).rejects.toThrow('network down');
});

test('uses base endpoint from useConfig each call', async () => {
  // prove we read fresh config (not cached in test)
  useConfigMock.mockReturnValueOnce({ API_BASE_ENDPOINT: 'A' });
  useConfigMock.mockReturnValueOnce({ API_BASE_ENDPOINT: 'B' });
  useAppGlobalStateMock.mockReturnValue(TOKEN);
  processHttpRequestMock.mockResolvedValue({ ok: true });

  const { result } = renderHook(() => useApiService());
  const r1 = makeReq({ endpoints: '/one' });
  const r2 = makeReq({ endpoints: '/two' });

  await act(async () => {
    await result.current.makeRequest(r1);
    await result.current.makeRequest(r2);
  });

  expect(processHttpRequestMock).toHaveBeenNthCalledWith(1, r1, TOKEN.access_token, 'A');
  expect(processHttpRequestMock).toHaveBeenNthCalledWith(2, r2, TOKEN.access_token, 'B');
});
