// src/provision/provision-list.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

// --- Component under test
import ProvisionList from './provision-list';

// --- Router
const navigateMock = jest.fn();
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => navigateMock,
}));

// --- API + utils
const makeRequestMock = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
}));

// keep data as‑is for the component’s dataParsing step
jest.mock('../utils/dataParsing', () => ({
  __esModule: true,
  default: (d: unknown) => d,
}));

// --- Context
const setProvisionDataMock = jest.fn();
function makeContext(tokens?: { githubToken?: string; terraformToken?: string }) {
  return {
    provisioningData: {
      githubToken: tokens?.githubToken ?? '',
      terraformToken: tokens?.terraformToken ?? '',
    },
    setprovisionData: setProvisionDataMock,
  };
}
jest.mock('../provisionContext', () => ({
  __esModule: true,
  useProvisionContext: () => makeContext(),
}));

// --- Auth + ConfApi
jest.mock('../gcp_oauth/hooks/useAuth', () => ({
  __esModule: true,
  default: () => ({ loading: false, isAuthenticated: true }),
}));

// This file does not exist on disk; mock as a virtual module
jest.mock('../gcp_oauth/hooks/useConfApi', () => ({
  __esModule: true,
  default: () => ({ API_BASE_ENDPOINT: 'http://api.example.com' }),
}), { virtual: true });

// --- Child components
// Very small navbar stub just so it renders
jest.mock('../home/CustomNavigation', () => ({
  __esModule: true,
  default: () => <div data-testid="nav" />,
}));

// Replace the custom Dropdown with a simple <select>
// It accepts data-testid (the component in your file passes that)
jest.mock('../components/dropdown/Dropdown', () => ({
  __esModule: true,
  default: ({ options = [], onChange, ...rest }: any) => (
    <select
      data-testid={rest['data-testid'] ?? 'dropdown'}
      onChange={e => {
        const idx = Number(e.target.value);
        const choice = options[idx];
        onChange?.(choice); // send back the chosen option object
      }}
    >
      {options.map((opt: any, i: number) => (
        <option key={String(opt.id ?? i)} value={i}>{opt.label ?? opt.value}</option>
      ))}
    </select>
  ),
}));

// ----------------------------------------------------------------------------
// Fixtures
// ----------------------------------------------------------------------------

const projectEnvList = [
  // app abc-999 has dev + qa (non-prod visible)
  { id: 1, projectid: 'abc-999', project_id: 'abc-999', env_id: 'dev', env: 'dev' },
  { id: 2, projectid: 'abc-999', project_id: 'abc-999', env_id: 'qa',  env: 'qa'  },
  // another app to switch to
  { id: 3, projectid: 'xyz-123', project_id: 'xyz-123', env_id: 'dev', env: 'dev' },
];

const validationRowsA = [
  { App_id: 'abc-999', enablementJiraStatus: 'Open', actJiraStatus: 'Pending', Environment: 'dev' },
];

const validationRowsB = [
  { App_id: 'xyz-123', enablementJiraStatus: 'In Progress', actJiraStatus: 'Open', Environment: 'dev' },
];

// helper to prime API sequence that the component performs:
// 1) GET /provisions/getAppIdEnvDetails
// 2) GET <created endpoint> for validations
function primeBootstrap(validRows = validationRowsA) {
  makeRequestMock.mockReset();

  // 1) project/env list
  makeRequestMock.mockResolvedValueOnce({ data: projectEnvList });

  // 2) first validations fetch
  makeRequestMock.mockResolvedValueOnce({ data: validRows });
}

// util to wait until the table appears and we have a “Provision” button
async function getProvisionButton(index = 0) {
  // wait for heading
  await screen.findByText(/Provision List/i);

  // some rows render asynchronously
  const buttons = await screen.findAllByRole('button', { name: /provision/i });
  return buttons[index]!;
}

// Silence window.alert used in code paths
beforeAll(() => {
  jest.spyOn(window, 'alert').mockImplementation(() => {});
});

afterEach(() => {
  jest.clearAllMocks();
});

// ----------------------------------------------------------------------------
// Tests
// ----------------------------------------------------------------------------

describe('ProvisionList', () => {
  test('loads project/env data, automatically fetches validation details, and renders table', async () => {
    primeBootstrap();

    render(<ProvisionList />);

    // 1) initial GET for app/env list
    await waitFor(() => {
      expect(makeRequestMock).toHaveBeenCalledWith(expect.objectContaining({
        method: 'GET',
        endPoints: '/provisions/getAppIdEnvDetails',
        responseType: 'json',
      }));
    });

    // 2) then validations GET (URL produced by createEndPointUrl inside component)
    await waitFor(() => {
      expect(makeRequestMock).toHaveBeenCalledTimes(2);
    });

    // Table shows a row and the Provision button
    expect(await screen.findByText(/Application Task Validation/i)).toBeInTheDocument();
    expect(await screen.findByRole('button', { name: /provision/i })).toBeInTheDocument();
  });

  test('switching project and environment triggers a fresh validation fetch', async () => {
    primeBootstrap(validationRowsA);

    render(<ProvisionList />);

    // Ensure the two bootstrap calls occurred
    await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(2));

    // Re-prime API for the re-fetch caused by selection change
    makeRequestMock.mockResolvedValueOnce({ data: validationRowsB });

    // Change project -> select second option (xyz-123)
    const projSelect = await screen.findByTestId('project-dropdown');
    fireEvent.change(projSelect, { target: { value: '1' } }); // index 1 is xyz-123

    // Change env -> the first option for xyz-123 (dev)
    const envSelect = await screen.findByTestId('environment-dropdown');
    fireEvent.change(envSelect, { target: { value: '0' } });

    // Expect the new validations fetch
    await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(3));
  });

  test('clicking Provision opens the token dialog when tokens are missing', async () => {
    primeBootstrap();

    render(<ProvisionList />);

    const provisionBtn = await getProvisionButton();
    fireEvent.click(provisionBtn);

    // dialog title from your file
    expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();
    // and the token fields
    expect(await screen.findByLabelText(/Github Token/i)).toBeInTheDocument();
    expect(await screen.findByLabelText(/Terraform Token/i)).toBeInTheDocument();
  });

  test('clicking Provision navigates when both tokens exist', async () => {
    // Provide non-empty tokens through the context mock
    (jest.requireMock('../provisionContext') as any).useProvisionContext = () =>
      makeContext({ githubToken: 'gh', terraformToken: 'tf' });

    primeBootstrap();

    render(<ProvisionList />);

    const provisionBtn = await getProvisionButton();
    fireEvent.click(provisionBtn);

    await waitFor(() => {
      expect(navigateMock).toHaveBeenCalled();
    });
  });

  test('fills tokens in dialog and submits to close the dialog path', async () => {
    // Empty tokens to force dialog open
    (jest.requireMock('../provisionContext') as any).useProvisionContext = () =>
      makeContext({ githubToken: '', terraformToken: '' });

    primeBootstrap();

    render(<ProvisionList />);

    const provisionBtn = await getProvisionButton();
    fireEvent.click(provisionBtn);

    // Fill both inputs
    const gh = await screen.findByLabelText(/Github Token/i);
    const tf = await screen.findByLabelText(/Terraform Token/i);
    fireEvent.change(gh, { target: { value: 'gh-token-1' } });
    fireEvent.change(tf, { target: { value: 'tf-token-1' } });

    // Submit
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // Dialog should go away (title no longer present)
    await waitFor(() => {
      expect(screen.queryByText(/Action Required/i)).toBeNull();
    });

    // Context setter called with latest values
    expect(setProvisionDataMock).toHaveBeenCalled();
  });
});
