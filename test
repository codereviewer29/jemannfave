// src/sideNavbar/boarding/intake-components/saferoomIntakeForm.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// ---- SUT ----
import SaferoomIntakeForm from './saferoomIntakeForm';

// ---- App Form Context mock ----
const setFormData = jest.fn();
const useFormContextMock = jest.fn();

jest.mock('../FormContext', () => ({
  // keep the hook name that your component imports
  useFormContext: () => useFormContextMock(),
}));

// ---- MUI + icons stubs (no MUI dependency) ----
jest.mock('@mui/material', () => {
  const React = require('react');

  const Pass = ({ children }: { children: React.ReactNode }) => <>{children}</>;
  const Box = Pass;
  const Grid = Pass;
  const FormControl = Pass;
  const InputLabel = ({ children }: { children: React.ReactNode }) => (
    <div>{children}</div>
  );
  const MenuItem = ({ children }: { children: React.ReactNode }) => <>{children}</>;
  const Tooltip = ({
    title,
    children,
  }: {
    title?: React.ReactNode;
    children: React.ReactNode;
  }) => (
    <div>
      <div data-testid="tooltip-title">{title}</div>
      {children}
    </div>
  );

  // Minimal Select -> real HTML <select> so we can interact
  const Select = ({
    label,
    id,
    name,
    value,
    onChange,
    children,
    disabled,
    ...rest
  }: {
    label?: string;
    id?: string;
    name?: string;
    value?: any;
    onChange?: (e: any) => void;
    children?: React.ReactNode;
    disabled?: boolean;
  }) => {
    const toOptions = (nodes: React.ReactNode) =>
      React.Children.toArray(nodes).map((n: any, i: number) => {
        if (!n?.props) return null;
        return (
          <option key={i} value={n.props.value}>
            {n.props.children}
          </option>
        );
      });

    return (
      <label htmlFor={id}>
        {label}
        <select
          id={id}
          name={name}
          aria-label={label}
          value={value ?? ''}
          onChange={(e) =>
            onChange?.({ target: { name: e.target.name, value: e.target.value } })
          }
          disabled={disabled}
          {...rest}
        >
          {toOptions(children)}
        </select>
      </label>
    );
  };

  return {
    __esModule: true,
    Box,
    Grid,
    FormControl,
    InputLabel,
    MenuItem,
    Select,
    Tooltip,
  };
});

jest.mock('@mui/icons-material/Info', () => ({
  __esModule: true,
  default: () => <span data-testid="info-icon" />,
}));

// ---- Test helpers ----
const baseFormData = {
  cdpDetails: { versionCDPRequired: '' },
  safeRoomDetails: { dataLoadRequired: 'Cloud Storage' },
};

function setup(formData = baseFormData) {
  setFormData.mockClear();
  useFormContextMock.mockReturnValue({
    formData,
    setFormData,
  });
  const user = userEvent.setup();
  render(<SaferoomIntakeForm validationErrors={{}} />);
  const combo = screen.getByRole('combobox', {
    name: /select the saferoom data load capability/i,
  });
  return { user, combo, formData };
}

describe('SaferoomIntakeForm', () => {
  test('renders overview text, section header, tooltip and icon', () => {
    setup();

    // Static copy checks to increase line coverage
    expect(
      screen.getByRole('heading', { name: /saferoom overview/i })
    ).toBeInTheDocument();

    expect(
      screen.getByText(/please select the required data load capability for saferoom/i)
    ).toBeInTheDocument();

    // Tooltip/title stub present
    expect(screen.getByTestId('tooltip-title')).toBeInTheDocument();
    expect(screen.getByTestId('info-icon')).toBeInTheDocument();
  });

  test('renders select with initial value and options', () => {
    const { combo } = setup();

    // Initial value from context
    expect(combo).toHaveDisplayValue(/cloud storage/i);

    // Both options present
    expect(screen.getAllByRole('option').map((o) => o.textContent)).toEqual([
      'Cloud Storage',
      'Big Query',
    ]);
  });

  test('updates formData.safeRoomDetails.dataLoadRequired on change', async () => {
    const { user, combo, formData } = setup();

    await user.selectOptions(combo, 'Big Query');

    // Nested update shape must be preserved
    expect(setFormData).toHaveBeenCalledTimes(1);
    expect(setFormData).toHaveBeenCalledWith({
      ...formData,
      safeRoomDetails: {
        ...formData.safeRoomDetails,
        dataLoadRequired: 'Big Query',
      },
    });
  });

  test('respects existing value when starting with Big Query', () => {
    setup({
      ...baseFormData,
      safeRoomDetails: { dataLoadRequired: 'Big Query' },
    });

    expect(
      screen.getByRole('combobox', {
        name: /select the saferoom data load capability/i,
      })
    ).toHaveDisplayValue(/big query/i);
  });
});
