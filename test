import { renderHook, waitFor } from '@testing-library/react';
import axios from 'axios';

// ---- mock the JSON env exactly as the hook imports it ----
const BASE = 'https://api.example.com';
jest.mock('../../assets/json/env-properties.json', () => ({
  API_BASE_ENDPOINT: BASE,
}));

// ---- mock axios default export ----
jest.mock('axios', () => ({
  __esModule: true,
  default: {
    get: jest.fn(),
  },
}));

// import AFTER mocks so the hook uses the mocked modules
import useAuth from './useAuth';

const axiosMock = axios as unknown as {
  get: jest.Mock<Promise<unknown>, [string, { withCredentials: boolean }]>;
};

describe('useAuth', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('calls GET {BASE}/auth/user withCredentials: true', async () => {
    axiosMock.get.mockResolvedValueOnce({ data: { isAuthenticated: true } });

    const { result } = renderHook(() => useAuth());

    await waitFor(() => expect(result.current.loading).toBe(false));

    expect(axiosMock.get).toHaveBeenCalledTimes(1);
    expect(axiosMock.get).toHaveBeenCalledWith(`${BASE}/auth/user`, {
      withCredentials: true,
    });
    expect(result.current.isAuthenticated).toBe(true);
  });

  test('sets isAuthenticated=false when API returns false', async () => {
    axiosMock.get.mockResolvedValueOnce({ data: { isAuthenticated: false } });

    const { result } = renderHook(() => useAuth());

    await waitFor(() => expect(result.current.loading).toBe(false));

    expect(result.current.isAuthenticated).toBe(false);
  });

  test('sets isAuthenticated=false when request rejects', async () => {
    axiosMock.get.mockRejectedValueOnce(new Error('network'));

    const { result } = renderHook(() => useAuth());

    await waitFor(() => expect(result.current.loading).toBe(false));

    expect(result.current.isAuthenticated).toBe(false);
  });

  test('fires only once (useEffect has empty deps)', async () => {
    axiosMock.get.mockResolvedValueOnce({ data: { isAuthenticated: true } });

    const { result, rerender } = renderHook(() => useAuth());

    // re-render should NOT trigger another call
    rerender();

    await waitFor(() => expect(result.current.loading).toBe(false));

    expect(axiosMock.get).toHaveBeenCalledTimes(1);
  });
});
