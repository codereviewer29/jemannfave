// src/sideNavbar/boarding/intake-components/gcpComponentIntakeForm.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { createMemoryRouter, RouterProvider } from 'react-router-dom';

// ---- FormContext mock
const setFormData = jest.fn();
const useFormContextMock = jest.fn();
jest.mock('../FormContext', () => ({
  useFormContext: () => useFormContextMock(),
}));

// ---- MUI stubs
jest.mock('@mui/material', () => {
  const React = require('react');
  const Pass = ({ children, ...rest }: any) => <div {...rest}>{children}</div>;
  const Alert = ({ children, severity }: any) => (
    <div role="alert" data-severity={severity}>
      {children}
    </div>
  );
  const Tooltip = ({ title, children }: any) => (
    <div>
      <div data-testid="tooltip-title">{title}</div>
      {children}
    </div>
  );
  const Typography = ({ children }: any) => <div>{children}</div>;
  const Divider = Pass;
  return {
    __esModule: true,
    Box: Pass,
    Grid: Pass,
    Alert,
    Tooltip,
    Typography,
    Divider,
  };
});

// IMPORTANT: TextField comes from a *separate* path
jest.mock('@mui/material/TextField', () => {
  const React = require('react');
  return {
    __esModule: true,
    default: ({ label, name, value, onChange, disabled, placeholder }: any) => (
      <label>
        {label}
        <input
          aria-label={label}
          name={name}
          // use uncontrolled input so userEvent composes full value
          defaultValue={value ?? ''}
          placeholder={placeholder}
          disabled={disabled}
          onChange={(e) =>
            onChange?.({ target: { name, value: e.currentTarget.value } })
          }
        />
      </label>
    ),
  };
});

jest.mock('@mui/icons-material/ErrorOutline', () => ({
  __esModule: true,
  default: (props: any) => <span data-testid="error-outline-icon" {...props} />,
}));

// ---- SUT AFTER mocks
import GCPComponentIntakeForm from './gcpComponentIntakeForm';

// ---- Helpers
function renderWithDataRouter(ui: React.ReactElement) {
  const router = createMemoryRouter([{ path: '/', element: ui }], {
    initialEntries: ['/'],
  });
  return render(<RouterProvider router={router} />);
}

const baseFormData = {
  gcpComponentDetails: {
    bucketName: '',
    bqDatasetName: '',
  },
};

function setup() {
  jest.clearAllMocks();
  useFormContextMock.mockReturnValue({
    formData: baseFormData,
    setFormData,
    isReadOnly: false,
  });

  const user = userEvent.setup();
  renderWithDataRouter(<GCPComponentIntakeForm validationErrors={{}} />);

  const bucket = screen.getByPlaceholderText(/bucket/i);
  const dataset = screen.getByPlaceholderText(/discriminator/i);
  return { user, bucket, dataset };
}

// flexible textContent matcher (handles split/nested nodes)
const textMatches = (re: RegExp) => (_: string, node: Element | null) =>
  !!node?.textContent && re.test(node.textContent.replace(/\s+/g, ' ').trim());

// ---- Tests
describe('GCPComponentIntakeForm', () => {
  test('renders static intro text and list items', () => {
    setup();

    expect(
      screen.getByText(
        textMatches(
          /the application data project and cdm next project are key gcp components/i
        )
      )
    ).toBeInTheDocument();

    expect(screen.getByText(textMatches(/gcs\(google cloud storage\)\s*buckets/i))).toBeInTheDocument();
    expect(screen.getByText(textMatches(/cloud\s*scheduler/i))).toBeInTheDocument();
    expect(screen.getByText(textMatches(/big\s*query/i))).toBeInTheDocument();
    expect(screen.getByText(textMatches(/kms\s*keys/i))).toBeInTheDocument();

    expect(screen.getAllByTestId('tooltip-title').length).toBeGreaterThan(0);
    expect(screen.getAllByTestId('error-outline-icon').length).toBeGreaterThan(0);
  });

  test('renders both inputs with placeholders', () => {
    const { bucket, dataset } = setup();

    expect(bucket).toBeInTheDocument();
    expect(bucket).toHaveAttribute('placeholder', expect.stringMatching(/bucket/i));

    expect(dataset).toBeInTheDocument();
    expect(dataset).toHaveAttribute('placeholder', expect.stringMatching(/discriminator/i));
  });

  test('updates formData.gcpComponentDetails.bucketName when typing', async () => {
    const { user, bucket } = setup();

    await user.type(bucket, 'bucket_1');
    expect(setFormData).toHaveBeenLastCalledWith({
      ...baseFormData,
      gcpComponentDetails: {
        ...baseFormData.gcpComponentDetails,
        bucketName: 'bucket_1',
      },
    });
  });

  test('updates formData.gcpComponentDetails.bqDatasetName when typing', async () => {
    const { user, dataset } = setup();

    await user.type(dataset, 'disc_123_appid');
    expect(setFormData).toHaveBeenLastCalledWith({
      ...baseFormData,
      gcpComponentDetails: {
        ...baseFormData.gcpComponentDetails,
        bqDatasetName: 'disc_123_appid',
      },
    });
  });
});
