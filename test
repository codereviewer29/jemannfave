// Keep a mutable stub the mock can read
let ctxStub: any = null;

// Mock ONLY the hook; re-export everything else (like initialFormData)
jest.mock('./FormContext', () => {
  const real = jest.requireActual('./FormContext');
  return {
    __esModule: true,
    ...real,
    useFormContext: () => ctxStub,   // our stub will be assigned after we build baseFormData
  };
});

// (optionally) use the real initial to get the right nested shape
import { initialFormData as realInitial } from './FormContext';

// Build a safe base shape the component expects
const baseFormData = {
  ...realInitial,
  applicationDetails: {
    ...(realInitial as any).applicationDetails,
    applicationID: '',
    applicationName: '',
    summary: '',
    description: '',
    purposeAndBenefit: '',
    lobDomain: '',
    environmentsNeeded: [],
    requesterName: '',
    requesterEmail: '',
    businessExecutiveSponsor: '',
    applicationBusinessOwner: '',
    applicationPortfolioOwner: '',
    techExecutiveSponsor: '',
    primaryTechManager: '',
    cloudAccountableExecutive: '',
    applicationArchitect: '',
    auNumber: '',
    techContact: '',
    dmiCloudContact: '',
    serviceNowSupportGroup: '',
    applicationOwnerApprover: '',
    timelineSandbox: null,
    timelineNonProd: null,
    timelineProd: null,
    datasource: '',
    dataFormat: [],
    dataSLATime: '',
    dataClassification: 'public',
    panCardDataInScope: '',
    panCardDetails: '',
    sarUarData: '',
    internationalUsers: '',
    externalIngress: '',
    externalIngressDetails: '',
    serviceNowCI: '',
    technicalConstraints: '',
    reviewedWithCIO: '',
    reviewedWithArchitect: '',
    requiresCloudReview: '',
  },
} as any;

// A single mock for setFormData that tests can assert against
const setFormDataMock = jest.fn();

// IMPORTANT: assign the context stub AFTER baseFormData is created
ctxStub = {
  formData: baseFormData,
  setFormData: setFormDataMock,
  requiredFields: [],
  resetFormData: jest.fn(),
};
