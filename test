import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/** -------------------- FormContext mock -------------------- */
const setFormDataMock = jest.fn();
const resetFormDataMock = jest.fn();
let requiredFieldsMock: string[] = [];
let formDataMock: any = { trackingStatus: '', appDetails: {}, cdmNextDetails: {} };
const initialFormDataMock = { trackingStatus: '', appDetails: {}, cdmNextDetails: {} };

jest.mock('../FormContext', () => ({
  __esModule: true,
  useFormContext: () => ({
    formData: formDataMock,
    setFormData: setFormDataMock,
    resetFormData: resetFormDataMock,
    requiredFields: requiredFieldsMock,
    initialFormData: initialFormDataMock,
  }),
}));

/** -------------------- API mock -------------------- */
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

/** -------------------- Router + Nav mocks -------------------- */
const navigateMock = jest.fn();
let paramsMock: Record<string, string | undefined> = {};

jest.mock('react-router-dom', () => ({
  __esModule: true,
  useNavigate: () => navigateMock,
  useParams: () => paramsMock,
  // minimal useLocation so CustomNavigation (if ever rendered) won’t explode
  useLocation: () => ({ pathname: '/', search: '', hash: '', state: null, key: 'k' }),
  Link: ({ to, children }: { to: string; children: React.ReactNode }) => (
    <a href={typeof to === 'string' ? to : ''}>{children}</a>
  ),
}));

// Mock CustomNavigation entirely so we don’t execute its internals
jest.mock('../../home/CustomNavigation', () => () => <nav data-testid="nav" />);

/** ---- child stubs rendered inside StartOnboarding (keep very light) ---- */
jest.mock('./intake-components/applicationDetails', () => () => (
  <div data-testid="app-details" />
));
jest.mock('./intake-components/componentsDetails', () => () => (
  <div data-testid="components-details" />
));
jest.mock('./intake-components/guidelinesIntakeForm', () => () => (
  <div data-testid="guidelines" />
));

// Cancel dialog: only render its controls when asked to open
jest.mock('./intake-components/cancelOnboarding', () => (props: any) =>
  props.openCancelDialog ? (
    <button data-testid="mock-cancel-confirm" onClick={props.handleConfirmCancel} />
  ) : null
);

// Submit-confirm dialog: only render when asked to open
jest.mock('./intake-components/confirmationOnboarding', () => (props: any) =>
  props.openConfirmSubmitDialog ? (
    <button data-testid="mock-submit-confirm" onClick={props.handleConfirmSubmit} />
  ) : null
);

/** -------------------- SUT -------------------- */
import StartOnboarding from './startOnboarding';

describe('StartOnboarding', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    paramsMock = {};                  // default: no trackingId
    requiredFieldsMock = [];          // default: no required fields
    formDataMock = { trackingStatus: '', appDetails: {}, cdmNextDetails: {} };
  });

  test('mount with trackingId → fetches data and shows id', async () => {
    paramsMock = { trackingId: '123' };
    makeRequest.mockResolvedValueOnce({ data: { foo: 'bar' }, status: 200 });

    render(<StartOnboarding />);

    await waitFor(() => expect(makeRequest).toHaveBeenCalled());
    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        endpoints: '/api/intake-form?intakeFormTrackingId=123',
        responseType: 'json',
      })
    );
    expect(setFormDataMock).toHaveBeenCalledWith({ foo: 'bar' });
    expect(screen.getByText(/tracking id/i)).toBeInTheDocument();
    expect(screen.getByText('123')).toBeInTheDocument();
  });

  test('mount without trackingId → resets form and shows "Not Available"', () => {
    render(<StartOnboarding />);

    expect(resetFormDataMock).toHaveBeenCalled();

    // text might be split across nodes; match by element textContent
    expect(
      screen.getByText((_, el) => el?.textContent?.includes('Not Available') ?? false)
    ).toBeInTheDocument();
  });

  test('Save = POST /api/intake-form then navigates to /gcpOnboarding/:id', async () => {
    makeRequest.mockResolvedValueOnce({ data: { intakeFormTrackingId: 987 }, status: 200 });

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /save/i }));

    await waitFor(() => expect(makeRequest).toHaveBeenCalled());
    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'POST',
        endpoints: '/api/intake-form',
        responseType: 'json',
        body: expect.any(Object),
      })
    );
    expect(navigateMock).toHaveBeenCalledWith('/gcpOnboarding/987');
  });

  test('Save (network error) → logs error, no navigation', async () => {
    makeRequest.mockRejectedValueOnce(new Error('boom'));

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /save/i }));

    await waitFor(() => expect(makeRequest).toHaveBeenCalled());
    expect(navigateMock).not.toHaveBeenCalled();
  });

  test('getFormData non-200 → error toast; no confirm dialog', async () => {
    paramsMock = { trackingId: '555' };
    makeRequest.mockResolvedValueOnce({ data: {}, status: 500 });

    render(<StartOnboarding />);

    const alert = await screen.findByRole('alert');
    expect(alert.innerHTML).toMatch(/Error has occurred while fetching Intake Form/i);

    // our confirmation stub renders nothing unless open = true, so it should NOT be in DOM
    expect(screen.queryByTestId('mock-submit-confirm')).not.toBeInTheDocument();
  });

  test('Submit invalid → validation toast; no POST', async () => {
    // require one field so validation fails
    requiredFieldsMock = ['appDetails.name'];

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    const alert = await screen.findByRole('alert');
    expect(alert.innerHTML).toMatch(/Please fill in all required fields/i);

    // ensure no /api/submit-intake-form call was made
    expect(
      makeRequest.mock.calls.some((c) =>
        String(c[0]?.endpoints).includes('/api/submit-intake-form')
      )
    ).toBe(false);
  });

  test('Submit valid → POST submit, success toast, confirm navigates to inbox', async () => {
    requiredFieldsMock = []; // valid

    makeRequest.mockResolvedValueOnce({ data: { intakeFormTrackingId: 4321 }, status: 200 });

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() =>
      expect(
        makeRequest.mock.calls.some((c) =>
          String(c[0]?.endpoints).includes('/api/submit-intake-form')
        )
      ).toBe(true)
    );

    const alert = await screen.findByRole('alert');
    expect(alert.innerHTML).toMatch(/submitted successfully/i);

    // confirm dialog (our stub) appears only when the component sets "open"
    fireEvent.click(screen.getByTestId('mock-submit-confirm'));
    expect(navigateMock).toHaveBeenCalledWith('/inbox');
  });

  test('Submit non-200 → error toast (no confirm dialog)', async () => {
    requiredFieldsMock = [];
    makeRequest.mockResolvedValueOnce({ data: {}, status: 500 });

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    const alert = await screen.findByRole('alert');
    expect(alert.innerHTML).toMatch(/Error has occurred while submitting Intake Form/i);

    expect(screen.queryByTestId('mock-submit-confirm')).not.toBeInTheDocument();
  });

  test('Cancel confirm with trackingId → re-fetches and sets data', async () => {
    paramsMock = { trackingId: '123' };
    // first resolve for mount, second for cancel-confirm
    makeRequest
      .mockResolvedValueOnce({ data: { a: 1 }, status: 200 })
      .mockResolvedValueOnce({ data: { a: 2 }, status: 200 });

    render(<StartOnboarding />);
    fireEvent.click(screen.getByRole('button', { name: /cancel/i }));
    fireEvent.click(screen.getByTestId('mock-cancel-confirm'));

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(2));
    expect(setFormDataMock).toHaveBeenCalledWith({ a: 2 });
  });

  test('Cancel confirm without trackingId → resets to initialFormData', () => {
    paramsMock = {};
    render(<StartOnboarding />);

    fireEvent.click(screen.getByRole('button', { name: /cancel/i }));
    fireEvent.click(screen.getByTestId('mock-cancel-confirm'));

    expect(setFormDataMock).toHaveBeenCalledWith(initialFormDataMock);
  });

  test('buttons disabled when trackingStatus = Completed', () => {
    formDataMock = { ...formDataMock, trackingStatus: 'Completed' };
    render(<StartOnboarding />);

    expect(screen.getByRole('button', { name: /save/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();
  });

  test('tabs switch content', () => {
    render(<StartOnboarding />);

    // default Application tab
    expect(screen.getByTestId('app-details')).toBeInTheDocument();

    // Component Details
    fireEvent.click(screen.getByRole('button', { name: /component details/i }));
    expect(screen.getByTestId('components-details')).toBeInTheDocument();

    // Guide Lines
    fireEvent.click(screen.getByRole('button', { name: /guide lines/i }));
    expect(screen.getByTestId('guidelines')).toBeInTheDocument();
  });
});
