// src/sideNavbar/boarding/intake-components/saferoomIntakeForm.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';

// ───────────────────────── mock ../FormContext ─────────────────────────
// NOTE: the relative path must match the one used by saferoomIntakeForm.tsx
jest.mock('../FormContext', () => {
  // grab React at runtime so we can create a Context here
  const React = require('react') as typeof import('react');

  // define just the fields this component reads/writes
  type Ctx = {
    formData: any;
    setFormData: (updater: any) => void; // supports object & functional updaters
    requiredFields: string[];
    resetFormData: () => void;
  };

  const Context = (React as any).createContext<Ctx | null>(null);

  return {
    __esModule: true,
    FormContext: Context,
    useFormContext: () => {
      const v = React.useContext(Context);
      // helpful error if someone forgets to wrap with Provider
      if (!v) throw new Error('useFormContext used outside Provider in test');
      return v;
    },
  };
});

// pull the mocked context type/value back so we can render with Provider
import { FormContext } from '../FormContext';
import SafeRoomIntakeForm from './saferoomIntakeForm';

/* ─────────────────────────────── helpers ─────────────────────────────── */

type TextMatch = Parameters<typeof screen.getByLabelText>[0];

/** Open a MUI Select by its label (mouseDown on the input opens the menu) */
const openSelectByLabel = (label: TextMatch) => {
  const input = screen.getByLabelText(label, { selector: 'input' });
  fireEvent.mouseDown(input);
};

/** Build a Provider with the minimal, safe form shape that the component uses */
function withForm(overrides?: Partial<any>) {
  // minimal + correct keys (only keys used in this component)
  const baseFormData: any = {
    cdpDetails: { versionCDPRequired: '' }, // updated in useEffect based on selection
    safeRoomDetails: { dataLoadRequired: '' }, // bound to the Select
    ...(overrides || {}),
  };

  // updater that supports both object & functional setState shapes
  const setFormData = jest.fn((updater: any) => {
    if (typeof updater === 'function') {
      const next = updater(baseFormData);
      Object.assign(baseFormData, next);
    } else {
      Object.assign(baseFormData, updater);
    }
  });

  const value = {
    formData: baseFormData,
    setFormData,
    requiredFields: [],
    resetFormData: jest.fn(),
  };

  // ❗ JSX can’t handle <(FormContext as any).Provider>; alias it first
  const CtxProvider = (FormContext as any).Provider as React.ComponentType<
    React.PropsWithChildren<{ value: typeof value }>
  >;

  const Provider = ({ children }: { children: React.ReactNode }) => (
    <CtxProvider value={value}>{children}</CtxProvider>
  );

  return { Provider, setFormData, formData: baseFormData };
}

/* ─────────────────────────────── tests ─────────────────────────────── */

describe('SafeRoomIntakeForm', () => {
  test('renders overview copy and the Select (smoke)', () => {
    const { Provider } = withForm();

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    // overview text/content exists
    expect(screen.getByText(/Saferoom Overview/i)).toBeInTheDocument();
    expect(
      screen.getByText(/Saferoom ensures security, privacy/i)
    ).toBeInTheDocument();

    // the select’s input is labelled by your InputLabel text
    expect(
      screen.getByLabelText(/Select the Saferoom Data Load Capability/i, {
        selector: 'input',
      })
    ).toBeInTheDocument();
  });

  test('allows selecting Cloud Storage', () => {
    const { Provider, setFormData, formData } = withForm();

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(screen.getByRole('option', { name: /Cloud Storage/i }));

    // setFormData called and state patched
    expect(setFormData).toHaveBeenCalled();
    const arg = setFormData.mock.calls.pop()![0];
    const next =
      typeof arg === 'function' ? arg(formData) : (arg as typeof formData);

    expect(next.safeRoomDetails.dataLoadRequired.toLowerCase()).toBe(
      'cloud storage'
    );
    // and the effect target exists (kept for component safety)
    expect('cdpDetails' in formData).toBe(true);
  });

  test('allows selecting Big Query and shows validation error when provided', () => {
    const { Provider, setFormData, formData } = withForm({
      safeRoomDetails: { dataLoadRequired: '' },
    });

    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(screen.getByRole('option', { name: /Big Query/i }));

    expect(setFormData).toHaveBeenCalled();
    const arg = setFormData.mock.calls.pop()![0];
    const next =
      typeof arg === 'function' ? arg(formData) : (arg as typeof formData);

    expect(next.safeRoomDetails.dataLoadRequired.toLowerCase()).toBe(
      'big query'
    );

    // now re‑render with a validation message -> MUI marks the input aria-invalid
    const { Provider: Provider2 } = withForm({
      safeRoomDetails: { dataLoadRequired: '' },
    });

    render(
      <Provider2>
        <SafeRoomIntakeForm
          validationErrors={{ safeRoomDetails: { dataLoadRequired: 'Required field' } }}
        />
      </Provider2>
    );

    const selectInput = screen.getByLabelText(
      /Select the Saferoom Data Load Capability/i,
      { selector: 'input' }
    );
    expect(selectInput).toHaveAttribute('aria-invalid', 'true');
  });
});
