// src/sideNavbar/inbox.test.tsx
import React from 'react';
import { render, screen, fireEvent, within, act } from '@testing-library/react';

// --- mocks (unchanged) ---
jest.mock('../home/CustomNavigation', () => () => <div data-testid="nav" />);
jest.mock('react-router-dom', () => ({
  __esModule: true,
  Link: ({ to, children }: { to: string; children: React.ReactNode }) => (
    <a href={to} data-to={to}>
      {children}
    </a>
  ),
}));
jest.mock('@mui/icons-material/Info', () => () => <span data-testid="info-icon" />);
jest.mock('@mui/icons-material/PictureAsPdf', () => () => <span data-testid="pdf-icon" />);

const makeRequest = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

// --- FIX: define createObjectURL mock BEFORE importing the SUT ---
const createObjectURLMock = jest.fn(() => 'blob://url');
Object.defineProperty(global, 'URL', {
  // why: provide a minimal URL object with createObjectURL for JSDOM
  value: { createObjectURL: createObjectURLMock },
  writable: true,
});

import Inbox from './inbox';

// --- test data & helpers (unchanged) ---
const apiData = {
  data: {
    intakeFormList: [
      {
        intakeFormTrackingId: 101,
        appID: ['APP-A'],
        env: ['SIT'],
        status: 'Completed',
        enablementJira: 'EN-1',
        actJira: 'AC-1',
        cdmNextJira: 'CDM-1',
        lastModified: 'ignored',
        modifiedOn: '2025-01-10T10:00:00Z',
      },
      {
        intakeFormTrackingId: 55,
        appID: ['APP-B'],
        env: ['UAT'],
        status: 'In_Draft',
        enablementJira: 'EN-2',
        actJira: 'AC-2',
        cdmNextJira: 'CDM-2',
        lastModified: 'ignored',
        modifiedOn: '2024-12-30T08:00:00Z',
      },
    ],
  },
};

function setupSuccess() {
  makeRequest.mockResolvedValueOnce(apiData);
}
function setupFailure() {
  makeRequest.mockRejectedValueOnce(new Error('boom'));
}
function renderInbox() {
  return render(<Inbox />);
}

describe('Inbox', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (console.error as jest.Mock | undefined)?.mockClear?.();
    document.body.innerHTML = '';
  });

  test('loads data, sorts by modifiedOn desc, and renders rows', async () => {
    setupSuccess();
    renderInbox();

    const firstWithApp = await screen.findByText('APP-A');
    expect(firstWithApp).toBeInTheDocument();
    expect(screen.getByText(/Completed/)).toBeInTheDocument();
    expect(screen.getByText(/In Progress/)).toBeInTheDocument();
  });

  test('filters by search keyword', async () => {
    setupSuccess();
    renderInbox();

    const search = await screen.findByLabelText(/Search/i);
    fireEvent.change(search, { target: { value: 'APP-B' } });

    expect(screen.queryByText('APP-A')).not.toBeInTheDocument();
    expect(screen.getByText('APP-B')).toBeInTheDocument();
  });

  test('filters by status (In Progress includes In_Draft)', async () => {
    setupSuccess();
    renderInbox();

    const select = await screen.findByRole('button');
    fireEvent.mouseDown(select);
    const option = await screen.findByRole('option', { name: /In Progress/i });
    fireEvent.click(option);

    expect(screen.queryByText('Completed')).not.toBeInTheDocument();
    expect(screen.getByText('In Progress')).toBeInTheDocument();
  });

  test('sorts by appID column toggling asc/desc', async () => {
    setupSuccess();
    renderInbox();

    const header = await screen.findByText('APP ID');
    fireEvent.click(header);
    let rowsText = screen.getAllByRole('row').map((r) => r.textContent || '');
    expect(rowsText.join(' ')).toMatch(/APP-A[\s\S]*APP-B/);

    fireEvent.click(header);
    rowsText = screen.getAllByRole('row').map((r) => r.textContent || '');
    expect(rowsText.join(' ')).toMatch(/APP-B[\s\S]*APP-A/);
  });

  test('download PDF only for Completed rows triggers blob request and object URL creation', async () => {
    setupSuccess();
    // blob response for download
    makeRequest.mockResolvedValueOnce({ data: new Blob(['%PDF'], { type: 'application/pdf' }) });

    renderInbox();

    const completedCell = await screen.findByText('Completed');
    const rowEl = completedCell.closest('tr');
    expect(rowEl).not.toBeNull();

    // Find clickable <span style="cursor: pointer">
    const clickableSpans = Array.from(rowEl!.querySelectorAll('span')).filter((el) =>
      (el.getAttribute('style') || '').includes('cursor: pointer'),
    );
    expect(clickableSpans.length).toBeGreaterThan(0);

    fireEvent.click(clickableSpans[0]);

    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        endpoints: expect.stringContaining('/api/download-pdf'),
        responseType: 'blob',
      }),
    );
    expect(createObjectURLMock).toHaveBeenCalled();
  });

  test('logs when fetch fails', async () => {
    setupFailure();
    renderInbox();
    await act(async () => {});
    expect((console.error as jest.Mock).mock.calls.some((c) => /Error/.test(String(c[0])))).toBe(
      true,
    );
  });
});
