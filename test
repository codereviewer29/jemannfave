import { renderHook, act } from '@testing-library/react';
import useApiService from './useApiService';
import type { HttpRequest } from './types';

// ---- Mocks ----
jest.mock('@wf/react-library', () => ({
  useAppGlobalState: jest.fn(),
  useConfig: jest.fn(),
}));

jest.mock('./processHttp', () => ({
  processHttpRequest: jest.fn(),
}));

// Pull the mocked fns with types
import * as reactlib from '@wf/react-library';
import { processHttpRequest } from './processHttp';

const useAppGlobalStateMock = reactlib.useAppGlobalState as jest.Mock;
const useConfigMock = reactlib.useConfig as jest.Mock;
const processHttpRequestMock = processHttpRequest as jest.Mock;

const BASE = 'https://api.example.com';

beforeEach(() => {
  jest.clearAllMocks();
  // Always provide env so env.API_BASE_ENDPOINT is defined
  useConfigMock.mockReturnValue({ API_BASE_ENDPOINT: BASE });
});

// Helper: minimal, type-friendly request object
const makeReq = (path = '/things'): HttpRequest =>
  ({
    method: 'GET',
    // If your type uses `endpoint` (singular), rename this line accordingly.
    endpoints: path,
    responseType: 'json',
  } as unknown as HttpRequest);

// ---------------- Tests ----------------

test('calls processHttpRequest with (request, access_token, baseEndpoint)', async () => {
  const TOKEN = { access_token: 'abc123' };
  useAppGlobalStateMock.mockReturnValue(TOKEN);
  processHttpRequestMock.mockResolvedValue({ ok: true });

  const { result } = renderHook(() => useApiService());
  const req = makeReq('/things');

  await act(async () => {
    await result.current.makeRequest(req);
  });

  expect(processHttpRequestMock).toHaveBeenCalledTimes(1);
  expect(processHttpRequestMock).toHaveBeenCalledWith(req, TOKEN.access_token, BASE);
});

test('passes undefined token when global state has no token', async () => {
  useAppGlobalStateMock.mockReturnValue(undefined);
  processHttpRequestMock.mockResolvedValue({ ok: true });

  const { result } = renderHook(() => useApiService());
  const req = makeReq('/none');

  await act(async () => {
    await result.current.makeRequest(req);
  });

  expect(processHttpRequestMock).toHaveBeenCalledWith(req, undefined, BASE);
});

test('returns the resolved value from processHttpRequest', async () => {
  const TOKEN = { access_token: 'xyz' };
  useAppGlobalStateMock.mockReturnValue(TOKEN);

  const payload = { id: 7, name: 'thing' };
  processHttpRequestMock.mockResolvedValue(payload);

  const { result } = renderHook(() => useApiService());
  const req = makeReq('/thing/7');

  const value = await act(async () => result.current.makeRequest(req));
  // act() returns whatever the callback returns; for clarity re-await directly:
  const out = await result.current.makeRequest(req);

  expect(out).toBe(payload);
});

test('propagates errors from processHttpRequest', async () => {
  const TOKEN = { access_token: 'tok' };
  useAppGlobalStateMock.mockReturnValue(TOKEN);

  const err = new Error('network down');
  processHttpRequestMock.mockRejectedValue(err);

  const { result } = renderHook(() => useApiService());
  const req = makeReq('/oops');

  await expect(result.current.makeRequest(req)).rejects.toThrow('network down');
});
