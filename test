type Env = 'UAT' | 'SIT' | 'Sandbox';

const getEnvKeys = (env: Env) => {
  switch (env) {
    case 'SIT':     return { nameKey: 'sitvenafiFileName',     contentKey: 'sitvenafiFileContent' };
    case 'UAT':     return { nameKey: 'uatvenafiFileName',     contentKey: 'uatvenafiFileContent' };
    case 'Sandbox': return { nameKey: 'sandboxvenafiFileName', contentKey: 'sandboxvenafiFileContent' };
  }
};

const hasFileForEnv = (env: Env) => {
  const { nameKey } = getEnvKeys(env);
  return Boolean((formData?.cdnNextDetails as any)?.[nameKey]);
};

const handleUploadChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
  const files = event.target.files;
  const file = files && files[0];
  if (!file) return;

  // only upload to envs that do NOT already have a file
  const targets: Env[] = selectedEnvironments.filter((env) => !hasFileForEnv(env)) as Env[];

  // Nothing to do because all selected envs already have files
  if (targets.length === 0) {
    // optional: surface a small message/toast if you want
    // enqueueSnackbar('A file is already uploaded for these environments. Delete it to replace.', { variant: 'info' });
    if (fileInputRef.current) fileInputRef.current.value = '';
    return;
  }

  // UX: mark only target envs as pending
  setVenafiStatus((s) => {
    const next = { ...s };
    targets.forEach((env) => (next[env] = 'pending'));
    return next;
  });

  // Prepare form-data (your backend expects a single file)
  const venafiData = new FormData();
  venafiData.append('certificate_file', file);

  const httpRequest = {
    method: 'POST' as const,
    endpoints: '/upload-venafi-certificate/', // keep plural to match your service type
    responseType: 'json' as const,
    // IMPORTANT: DON'T set Content-Type for FormData. Browser will set boundary.
    body: venafiData,
  };

  try {
    const response = (await makeRequest(httpRequest)) as any;

    if (response?.data?.status === 'Success') {
      const fileName =
        response?.data?.sitfilename ||
        response?.data?.uatfilename ||
        response?.data?.sandboxfilename ||
        file.name;

      const fileContent =
        response?.data?.sitfilecontent ||
        response?.data?.uatfilecontent ||
        response?.data?.sandboxfilecontent ||
        '';

      // merge only for targets
      setFormData((prev) => {
        const next = { ...prev, cdnNextDetails: { ...prev.cdnNextDetails } } as any;
        targets.forEach((env) => {
          const { nameKey, contentKey } = getEnvKeys(env);
          next.cdnNextDetails[nameKey] = fileName || '';
          next.cdnNextDetails[contentKey] = fileContent || '';
        });
        return next;
      });

      // mark success for targets (leave others unchanged)
      setVenafiStatus((s) => {
        const next = { ...s };
        targets.forEach((env) => (next[env] = 'success'));
        return next;
      });
    } else {
      // API returned a failure
      setVenafiStatus((s) => {
        const next = { ...s };
        targets.forEach((env) => (next[env] = 'error'));
        return next;
      });
    }
  } catch (err) {
    // Network/exception
    setVenafiStatus((s) => {
      const next = { ...s };
      targets.forEach((env) => (next[env] = 'error'));
      return next;
    });
  } finally {
    // allow picking the same filename on next click
    if (fileInputRef.current) fileInputRef.current.value = '';
  }
};
