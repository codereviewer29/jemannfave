// src/provision/provision-list.test.tsx
import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import ProvisionList from './provision-list';
import '@testing-library/jest-dom';

// ------ Mocks ------

// Router
const navigateMock = jest.fn();
jest.mock('react-router-dom', () => ({
  // only what we use
  useNavigate: () => navigateMock,
}));

// Config + Auth
jest.mock('../gcp_oauth/hooks/useAuth', () => ({
  __esModule: true,
  default: () => ({ loading: false, isAuthenticated: true }),
}));

// If your project gets env via @wf/react-library useConfig,
// keep this mock; if not, it’s harmless.
jest.mock('@wf/react-library', () => ({
  useConfig: () => ({ API_BASE_ENDPOINT: 'https://api.example.com' }),
}));

// Provision context (tokens + setter)
const setProvisionDataMock = jest.fn();
let contextState = {
  provisioningData: {
    githubToken: '',
    terraformToken: '',
    githubRepo: [] as string[],
    githubBranch: [] as string[],
  },
  setProvisionData: setProvisionDataMock,
};
jest.mock('../provision/ProvisionContext', () => ({
  useProvisionContext: () => contextState,
}));

// Dropdown component => simple <select>
jest.mock('../components/dropdown/Dropdown', () => (props: any) => {
  const { options = [], onChange, ...rest } = props;
  return (
    <select
      data-testid={rest['data-testid'] || 'dropdown'}
      aria-label={rest['data-testid'] || 'dropdown'}
      value={rest.value?.value ?? ''}
      onChange={(e) =>
        onChange?.({ id: e.target.value, value: e.target.value, label: e.target.value })
      }
    >
      {options.map((o: any) => (
        <option key={`${o.id}-${o.value}`} value={o.value}>
          {o.label}
        </option>
      ))}
    </select>
  );
});

// Data parsing -> identity
jest.mock('../utils/dataParsing', () => ({
  __esModule: true,
  default: (x: any) => x,
}));

// Cosmetic wrappers (no-ops)
jest.mock('../home/CustomNavigation', () => () => <div data-testid="nav" />);

// API service hook
const makeRequestMock = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
}));

// MUI Icon components used inside dialogs/buttons (prevent warnings)
jest.mock('@mui/icons-material/InfoOutlined', () => () => <i />);
jest.mock('@mui/icons-material/Cancel', () => () => <i />);

// ------ Helpers / fixtures ------

type ProjectEnvRow = { id: number; projectid: string; env_id: string };

const projectEnvList: ProjectEnvRow[] = [
  { id: 10, projectid: 'abc-999', env_id: 'dev' },
  { id: 11, projectid: 'abc-999', env_id: 'qa' },
  { id: 21, projectid: 'def-111', env_id: 'dev' },
];

const validationRows = [
  {
    App_id: 'abc-999',
    enablementJiraStatus: 'Open',
    actjiraStatus: 'Pending',
    Environment: 'dev',
  },
];

function primeApiSuccess() {
  // 1st call: getAppIdEnvDetails
  makeRequestMock.mockResolvedValueOnce({ data: projectEnvList });
  // 2nd call: jira_automation validation list
  makeRequestMock.mockResolvedValueOnce({ data: validationRows });
}

// Common render
const renderPage = () => render(<ProvisionList />);

// Click helper on our mocked selects
const choose = (testId: string, value: string) => {
  const sel = screen.getByTestId(testId) as HTMLSelectElement;
  fireEvent.change(sel, { target: { value } });
};

// ------ Tests ------

describe('ProvisionList', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // default: no tokens so Provision button shows token dialog
    contextState = {
      provisioningData: { githubToken: '', terraformToken: '', githubRepo: [], githubBranch: [] },
      setProvisionData: setProvisionDataMock,
    };
    primeApiSuccess();
  });

  test('loads project/env data, automatically fetches validation details, and renders table', async () => {
    renderPage();

    // 1) initial GET for app/env list
    await waitFor(() => {
      expect(makeRequestMock).toHaveBeenCalledWith(
        expect.objectContaining({
          method: 'GET',
          endPoints: '/provisions/getAppIdEnvDetails',
        }),
      );
    });

    // After project/env bootstrap, component calls fetch for validation list
    await waitFor(() => {
      expect(makeRequestMock).toHaveBeenCalledWith(
        expect.objectContaining({
          method: 'GET',
          endPoints: expect.stringMatching(
            /jira_automation\/jira_board_feature\?intakeFormTrackingId=\d+&appid=.+&env=.+/,
          ),
        }),
      );
    });

    // Final table headers render
    expect(await screen.findByText(/Application Task Validation/i)).toBeInTheDocument();
    expect(screen.getByText(/GCP project task validation/i)).toBeInTheDocument();
    expect(screen.getByText(/Actions/i)).toBeInTheDocument();

    // Row + provision button appear
    expect(screen.getByText('abc-999')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /provision/i })).toBeInTheDocument();
  });

  test('switching project and environment triggers a fresh validation fetch', async () => {
    renderPage();

    // Ensure first two calls (bootstrap) went out
    await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(2));

    // Re-prime the API for the "change" flow call
    makeRequestMock.mockResolvedValueOnce({ data: validationRows });

    // Select project "def-111"
    choose('project-dropdown', 'def-111');

    // Select environment "dev" (for def-111)
    choose('environment-dropdown', 'dev');

    // Should trigger another validation fetch
    await waitFor(() =>
      expect(makeRequestMock).toHaveBeenCalledWith(
        expect.objectContaining({
          method: 'GET',
          endPoints: expect.stringMatching(/appid=def-111&env=dev/),
        }),
      ),
    );
  });

  test('clicking Provision opens the token dialog when tokens are missing', async () => {
    renderPage();

    // Wait for table row
    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);

    // Token dialog is shown
    expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();
    expect(screen.getByText(/Please provide below tokens/i)).toBeInTheDocument();
  });

  test('clicking Provision navigates when both tokens exist', async () => {
    // Re‑mount with tokens present
    contextState.provisioningData.githubToken = 'ghp_123';
    contextState.provisioningData.terraformToken = 'tf_456';

    renderPage();

    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);

    // The row’s values (from our fixture) are used to build the route
    await waitFor(() =>
      expect(navigateMock).toHaveBeenCalledWith('/provisions/abc-999/dev'),
    );
  });

  test('fills tokens in dialog and submits to close the dialog path', async () => {
    renderPage();

    // Open the token dialog
    const provisionBtn = await screen.findByRole('button', { name: /provision/i });
    fireEvent.click(provisionBtn);
    expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();

    // Type into the two TextFields
    fireEvent.change(screen.getByLabelText(/Github Token/i), {
      target: { value: 'gh-token' },
    });
    fireEvent.change(screen.getByLabelText(/Terraform Token/i), {
      target: { value: 'tf-token' },
    });

    // click Submit (the dialog’s submit path will check context tokens; we simulate setter having stored them)
    contextState.provisioningData.githubToken = 'gh-token';
    contextState.provisioningData.terraformToken = 'tf-token';

    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // Dialog should close; conservative check: the prompt text disappears
    await waitFor(() =>
      expect(screen.queryByText(/Please provide below tokens/i)).not.toBeInTheDocument(),
    );
  });
});
