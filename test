// src/sideNavBar/boarding/applicationDetails.test.tsx
import React from 'react';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ApplicationDetails from './applicationDetails';

/* -------------------- Mock FormContext (runtime require keeps TS quiet) -------------------- */
jest.mock('./FormContext', () => {
  // use require() so TypeScript doesn't try to type-check our mock module
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const React = require('react');
  // Keep this context private to the mock so the hook and provider share it
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const Ctx = React.createContext<any>(null);

  return {
    __esModule: true,
    useFormContext: () => React.useContext(Ctx),
    // Simple provider we can use in tests
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TestFormProvider: ({ value, children }: any) => (
      <Ctx.Provider value={value}>{children}</Ctx.Provider>
    ),
  };
});

// pull the provider from the mocked module *at runtime*
/* eslint-disable @typescript-eslint/no-var-requires */
const { TestFormProvider } = require('./FormContext');
/* eslint-enable @typescript-eslint/no-var-requires */

/* -------------------- Minimal, robust mocks for MUI X date pickers -------------------- */
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({
  __esModule: true,
  default: function AdapterDayjs() {
    return null;
  },
}));

jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  // render children directly – we’re not testing the picker internals
  LocalizationProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
}));

jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  // Plain input that calls onChange(value) to mimic MUI’s “value-first” API
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  DatePicker: ({ label, value, onChange }: any) => (
    <input
      aria-label={label}
      value={value ?? ''}
      onChange={(e) => onChange?.((e.target as HTMLInputElement).value)}
    />
  ),
}));

/* -------------------- Mock the API service used by the component -------------------- */
// Adjust this path if your component’s import is different
const makeRequestMock = jest.fn();
// ⚠️ path is relative to applicationDetails.tsx in your project
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
}));

/* -------------------- Helpers: base formData and renderer -------------------- */

// A safe, fully-shaped formData the component expects.
// Add any other fields your component reads during render to avoid runtime crashes.
function makeBaseFormData() {
  return {
    // other top-level slices your app uses are fine to include too
    actDetails: {},

    applicationDetails: {
      applicationID: '',
      applicationName: '',
      summary: '',
      description: '',
      purposeAndBenefit: '',
      lobDomain: '',
      requesterName: '',
      requesterEmail: '',
      businessExecutiveSponsor: '',
      applicationBusinessOwner: '',
      applicationPortfolioOwner: '',
      techExecutiveSponsor: '',
      primaryTechManager: '',
      cloudAccountableExecutive: '',
      applicationArchitect: '',
      auNumber: '',
      techContact: '',
      dmiCloudContact: '',
      serviceNowSupportGroup: '',
      developersList: '',
      applicationOwnerApprover: '',
      // timelines
      timelineSandbox: null,
      timelineNonProd: null,
      timelineProd: null,

      // planned/existing app info
      isNewApp: '',
      appLinkInBAM: '',
      beamsStatus: '',

      // dropdowns & multi-selects
      dataSource: 'External',
      dataFormat: [], // e.g. ["CSV"]
      environmentsNeeded: [],

      dataSLATime: '',
      dataClassification: '',

      panCardDataInScope: '',
      panCardDetails: '',

      sarUarData: '',

      internationalUsers: '',
      externalIngress: '',
      externalIngressDetails: '',

      serviceNowCI: '',
      technicalConstraints: '',

      // IMPORTANT: the code maps over Object.entries(...) – this must be a non-null object
      artRequestDetails: {}, // or e.g. { Sandbox: [] }
    },
  };
}

// Lightweight “render with context provider”
type RenderOpts = {
  // allow overriding pieces of formData per test
  formData?: ReturnType<typeof makeBaseFormData>;
  // spy replacement if you want to assert setFormData
  setFormData?: jest.Mock;
  // initial validation bucket shape
  validation?: Record<string, unknown>;
};

function renderWithProvider(opts: RenderOpts = {}) {
  const user = userEvent.setup();

  const formData = opts.formData ?? makeBaseFormData();
  const setFormData = opts.setFormData ?? jest.fn();

  const value = { formData, setFormData };

  const validationErrors =
    (opts.validation as Record<string, unknown>) ?? { applicationDetails: {} };
  const setValidationErrors = jest.fn();

  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <TestFormProvider value={value}>{children}</TestFormProvider>
  );

  render(
    <Wrapper>
      <ApplicationDetails
        validationErrors={validationErrors}
        setValidationErrors={setValidationErrors}
      />
    </Wrapper>
  );

  return { user, formData, setFormData, setValidationErrors };
}

/* ===================================== TESTS ===================================== */

describe('ApplicationDetails', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders key fields and headings', () => {
    renderWithProvider();

    // One heading from the Overview accordion summary
    expect(screen.getByText(/overview/i)).toBeInTheDocument();

    // A few representative fields by label
    expect(screen.getByLabelText(/application id/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/application name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/requester name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/requester email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/timeline for production/i)).toBeInTheDocument();
  });

  test('shows email validation message for invalid email', async () => {
    const { user, setValidationErrors } = renderWithProvider();

    // Enter an invalid email
    const email = screen.getByLabelText(/requester email/i);
    await user.clear(email);
    await user.type(email, 'not-an-email');

    // The component uses setValidationErrors(prev => ({ ...prev, ... }))
    // Verify we were called with an updater and that it writes the message
    expect(setValidationErrors).toHaveBeenCalled();
    const updater = setValidationErrors.mock.lastCall[0] as (
      prev: Record<string, any>
    ) => Record<string, any>;

    const next = updater({ applicationDetails: {} });
    expect(
      // @ts-expect-error – test-only shape
      next.applicationDetails?.requesterEmail ?? ''
    ).toMatch(/invalid email/i);
  });

  test('clicking the search icon on Application ID triggers BAM fetch', async () => {
    // Make the network mock resolve with BAM data
    makeRequestMock.mockResolvedValueOnce({
      data: {
        applicationID: 'APP-123',
        applicationName: 'Payments',
        lobDomain: 'CTO',
        applicationBusinessOwner: 'BO',
        applicationPortfolioOwner: 'PO',
        primaryTechManager: 'TM',
      },
    });

    const { user } = renderWithProvider();

    // Fill the App ID first
    const appId = screen.getByLabelText(/application id/i);
    await user.clear(appId);
    await user.type(appId, 'APP-123');

    // Click the IconButton that sits inside the Application ID adornment
    // (no accessible name on the icon, so query the button inside the field container)
    const field = appId.closest('div')!;
    await user.click(within(field).getByRole('button'));

    expect(makeRequestMock).toHaveBeenCalled();
    const calledWith = makeRequestMock.mock.calls[0][0];
    expect(String(calledWith.endpoints || calledWith.endpoint)).toMatch(/application-details\/bam/i);
  });

  test('multi-select "Environments Needed" displays selected values via renderValue', () => {
    const fd = makeBaseFormData();
    fd.applicationDetails.environmentsNeeded = ['DEV1', 'SIT'];

    renderWithProvider({ formData: fd });

    // The Select uses renderValue={(selected) => selected.join(', ')}
    expect(screen.getByText(/DEV1,\s*SIT/i)).toBeInTheDocument();
  });

  test('picks dates via DatePicker and stores ISO-like strings', async () => {
    const setFormDataSpy = jest.fn();
    const { user } = renderWithProvider({ setFormData: setFormDataSpy });

    // Our DatePicker mock renders an <input aria-label="Timeline for Production">
    const prod = screen.getByLabelText(/timeline for production/i);
    await user.clear(prod);
    await user.type(prod, '2025-01-12');

    // The component will call setFormData with applicationDetails.timelineProd = stringified value
    expect(setFormDataSpy).toHaveBeenCalled();
    const last = setFormDataSpy.mock.calls.pop()![0];

    // We don’t assert the exact ISO (timezone/plugins vary) – just that it's a stringy value
    expect(
      // @ts-expect-error test-only shape
      (last.applicationDetails?.timelineProd ?? '') as string
    ).toEqual(expect.any(String));
  });
});
