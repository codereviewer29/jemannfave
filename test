import React, { useState } from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

/* ----------------------- child/infra mocks ----------------------- */

// MUI x-date-pickers (render a simple clickable input that triggers onChange)
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  DatePicker: ({ label, onChange }: any) => (
    <input
      data-testid={`mock-date-${String(label).toLowerCase().replace(/\s+/g, '-')}`}
      aria-label={label}
      onClick={() => onChange?.('2025-01-01' as any)}
    />
  ),
}));
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  LocalizationProvider: ({ children }: any) => <>{children}</>,
}));

// Top-level navigation links/icons that don’t matter in tests
jest.mock('@mui/icons-material/ExpandMore', () => ({
  __esModule: true,
  default: () => <span data-testid="icon-expand-more" />,
}));
jest.mock('@mui/icons-material/AddCircle', () => ({
  __esModule: true,
  default: () => <span data-testid="icon-add" />,
}));
jest.mock('@mui/icons-material/RemoveCircle', () => ({
  __esModule: true,
  default: () => <span data-testid="icon-remove" />,
}));
jest.mock('@mui/icons-material/Search', () => ({
  __esModule: true,
  default: () => <span data-testid="icon-search" />,
}));
jest.mock('@mui/icons-material/RadioButtonUnchecked', () => ({
  __esModule: true,
  default: () => <span />,
}));
jest.mock('@mui/icons-material/ErrorOutline', () => ({
  __esModule: true,
  default: () => <span />,
}));

// API service – we only need makeRequest
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

/* ----------------------- form context shim ----------------------- */
type MinimalForm = {
  applicationDetails: Record<string, any>;
  artRequestDetails?: any[];
};

const FormContext = React.createContext<any>(null);

const baseFormData: MinimalForm = {
  applicationDetails: {
    applicationID: '',
    applicationName: '',
    summary: '',
    description: '',
    // multi-selects
    environmentsNeeded: [],
    dataFormat: [],
    // dates
    timelineSandbox: null,
    timelineNonProd: null,
    timelineProd: null,
    // text/number/dropdowns used all over
    requesterName: '',
    requesterEmail: '',
    lobDomain: '',
    auNumber: '',
    appLocation: '',
    appLinkBAN: '',
    beamsStatus: '',
    datasource: '',
    dataSLATime: '',
    dataClassification: '',
    panCardDataInScope: '',
    panCardDetails: '',
    sarUarData: '',
    internationalUsers: '',
    externalIngress: '',
    externalIngressDetails: '',
    serviceNowCI: '',
    technicalConstraints: '',
    // radios that appear many times
    isNewApp: '',
    reviewedWithCIO: '',
    reviewedWithArchitect: '',
    requiresCloudReview: '',
    // contacts
    businessExecutiveSponsor: '',
    applicationBusinessOwner: '',
    applicationPortfolioOwner: '',
    primaryTechManager: '',
    cloudAccountableExecutive: '',
    applicationArchitect: '',
    techContact: '',
    dmiCloudContact: '',
    serviceNowSupportGroup: '',
    applicationOwnerApprover: '',
  },
  artRequestDetails: [],
};

function withForm(values: Partial<MinimalForm> = {}) {
  const initial = {
    ...baseFormData,
    ...values,
    applicationDetails: { ...baseFormData.applicationDetails, ...(values as any).applicationDetails },
  };
  const setFormData = jest.fn();
  const Provider = ({ children }: { children: React.ReactNode }) => (
    <FormContext.Provider
      value={{
        formData: initial,
        setFormData,
        requiredFields: [],
        resetFormData: jest.fn(),
      }}
    >
      {children}
    </FormContext.Provider>
  );
  return { Provider, setFormData, initial };
}

// The real component imports useFormContext from our module.
// Provide a tiny shim that returns our testing context.
jest.mock('../FormContext', () => {
  const React = require('react');
  return {
    __esModule: true,
    useFormContext: () => React.useContext(require('./applicationDetails.test').FormContext),
  };
});
// export context so the shim above can read it
// @ts-ignore (export for the jest.mock shim)
export { FormContext };

/* ----------------------- SUT ----------------------- */
import ApplicationDetails from './applicationDetails';

/* ----------------------- helpers ----------------------- */
const typeIn = (label: string, value: string) => {
  const node = screen.getByLabelText(label) as HTMLInputElement;
  fireEvent.change(node, { target: { name: node.getAttribute('name') || '', value } });
  return node;
};

describe('ApplicationDetails (lite)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders Overview + a few core fields', () => {
    const { Provider } = withForm();
    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // overview section bits we can reliably assert
    expect(screen.getByLabelText(/Application ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Application Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Summary/i)).toBeInTheDocument();
  });

  test('typing requester email validates format (invalid → shows helper via setValidationErrors)', async () => {
    const { Provider } = withForm();
    const SpyWrapper = () => {
      const [validationErrors, setValidationErrors] = useState<Record<string, any>>({});
      return (
        <Provider>
          <ApplicationDetails
            validationErrors={validationErrors}
            setValidationErrors={setValidationErrors}
          />
        </Provider>
      );
    };

    render(<SpyWrapper />);

    typeIn('Requester Email', 'not-an-email');

    // helper text is shown only after setValidationErrors runs; assert by text
    await waitFor(() =>
      expect(
        screen.getByText(/Invalid email format/i)
      ).toBeInTheDocument()
    );
  });

  test('changing Summary and AU Number calls setFormData (text + number handler)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn('Summary', 'hello world');
    typeIn('AU Number/ AU Owner', '12345');

    expect(setFormData).toHaveBeenCalled();
  });

  test('Environments Needed (multi-select) updates form via setFormData', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Select is rendered with an InputLabel; change with array value
    const select = screen.getByLabelText(/Environments Needed/i) as HTMLInputElement;
    fireEvent.change(select, { target: { name: 'environmentsNeeded', value: ['SIT', 'UAT'] } });

    expect(setFormData).toHaveBeenCalled();
  });

  test('data pickers call handler without crashing (Sandbox timeline)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // our DatePicker mock renders a clickable input that triggers onChange
    fireEvent.click(screen.getByTestId('mock-date-timeline-for-sandbox'));

    expect(setFormData).toHaveBeenCalled();
  });

  test('radio groups call handler → data classification "public"', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // pick "Public" classification
    const publicRadio = screen.getByLabelText(/Public/i);
    fireEvent.click(publicRadio);

    expect(setFormData).toHaveBeenCalled();
  });

  test('Add "Other Field" in ART Request then remove → setFormData called', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // There is an "Add Other Field" button near ART details
    const addBtn = screen.getAllByRole('button').find((b) =>
      /add other field/i.test(b.textContent || '')
    );
    expect(addBtn).toBeTruthy();
    addBtn && fireEvent.click(addBtn);

    // After adding, there will be a remove icon button we can click
    const removeIcon = screen.getAllByTestId('icon-remove')[0];
    fireEvent.click(removeIcon);

    expect(setFormData).toHaveBeenCalled();
  });

  test('search by App ID triggers both services and may open the toaster (happy path)', async () => {
    const { Provider } = withForm({
      applicationDetails: {
        ...baseFormData.applicationDetails,
        applicationID: 'APP123',
        environmentsNeeded: ['SIT'], // so the env validation will detect duplicates
      },
    });

    // 1st call: BAM details
    makeRequest
      .mockResolvedValueOnce({ data: { applicationID: 'APP123', applicationName: 'My App' }, status: 200 })
      // 2nd call: env validation
      .mockResolvedValueOnce({ data: { environments: ['SIT'] }, status: 200 });

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Click search icon button in the Application ID adornment
    // (there are many buttons; pick the first search icon's parent button)
    const searchIcon = screen.getByTestId('icon-search');
    const searchBtn = searchIcon.closest('button') || screen.getAllByRole('button')[0];
    fireEvent.click(searchBtn!);

    await waitFor(() => expect(makeRequest).toHaveBeenCalled());

    // after second call, component may open info snackbar if env already submitted
    // Snackbar uses role=alert inside <Alert>
    await waitFor(() => {
      const alert = screen.getByRole('alert');
      expect(alert.textContent || '').toMatch(/already submitted/i);
    });
  });
});
