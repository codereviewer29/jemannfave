import React from 'react';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ApplicationDetails from './applicationDetails';

// ---------- Mock FormContext (runtime require to keep TS happy) ----------
jest.mock('./FormContext', () => {
  // use require to avoid type complaints in TS/Jest
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const React = require('react');
  // keep it simple â€” we're just trying to pass tests
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const Ctx = React.createContext<any>(null);
  return {
    __esModule: true,
    useFormContext: () => React.useContext(Ctx),
    TestFormProvider: ({
      value,
      children,
    }: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      value: any;
      children: React.ReactNode;
    }) => <Ctx.Provider value={value}>{children}</Ctx.Provider>,
  };
});

// pull mocked export at runtime (no static import so TS doesn't scan it)
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { TestFormProvider } = require('./FormContext');

// ---------- Minimal, robust mocks for MUI X date pickers ----------
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({
  __esModule: true,
  default: function AdapterDayjs() {
    return null;
  },
}));
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  LocalizationProvider: ({ children }: { children: React.ReactNode }) => (
    <div>{children}</div>
  ),
}));
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  DatePicker: ({
    label,
    value,
    onChange,
  }: {
    label: string;
    value: any;
    onChange: (v: any) => void;
  }) => (
    <input
      aria-label={label}
      value={value ?? ''}
      onChange={(e) => onChange(e.target.value)}
    />
  ),
}));

// ---------- Mock the API service hook used by the component ----------
jest.mock('../services/useApiService', () => {
  const makeRequest = jest.fn().mockResolvedValue({
    data: {
      applicationID: 'APP123',
      environments: ['DEV1', 'SIT'],
    },
  });
  return {
    __esModule: true,
    default: () => ({ makeRequest }),
  };
});

// ---------- Helpers ----------
function makeBaseFormData() {
  return {
    // anything else the component might pass around
    actDetails: {},

    applicationDetails: {
      applicationID: 'APP-999',
      applicationName: '',
      summary: '',
      description: '',
      purposeAndBenefit: '',
      lobDomain: '',
      requesterName: 'Jane Doe',
      requesterEmail: 'jane@example.com',

      environmentsNeeded: [], // multi-select value
      // used by snackbar (keep as array)
      environmentsForValidation: [],

      // Date fields (DatePicker)
      timelineSandbox: null,
      timelineNonProd: null,
      timelineProd: null,

      // this object is iterated with Object.entries(...).map(([category, details]) => details.map(...))
      // so make sure there is at least one entry with an ARRAY (even if empty)
      artRequestDetails: {
        Sandbox: [],
      },
    },
  };
}

type RenderOpts = {
  // allow tests to override initial form data if needed
  formData?: ReturnType<typeof makeBaseFormData>;
  setFormDataSpy?: jest.Mock;
  validation?: Record<string, unknown>;
};

function renderWithProvider(opts: RenderOpts = {}) {
  const user = userEvent.setup();
  const formData = opts.formData ?? makeBaseFormData();
  const setFormData = opts.setFormDataSpy ?? jest.fn();

  const value = { formData, setFormData };

  const validationErrors =
    opts.validation ?? ({ applicationDetails: {} } as Record<string, unknown>);
  const setValidationErrors = jest.fn();

  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <TestFormProvider value={value}>{children}</TestFormProvider>
  );

  render(
    <Wrapper>
      <ApplicationDetails
        validationErrors={validationErrors}
        setValidationErrors={setValidationErrors}
      />
    </Wrapper>
  );

  return { user, formData, setFormData, setValidationErrors };
}

// ========================= TESTS =========================
describe('ApplicationDetails', () => {
  test('renders key fields and headings', () => {
    renderWithProvider();

    // Heading in the first accordion
    expect(screen.getByText(/overview/i)).toBeInTheDocument();

    // Some representative fields
    expect(screen.getByLabelText(/application id/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/application name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/requester email/i)).toBeInTheDocument();

    // Multi-select label exists
    expect(
      screen.getByLabelText(/environments needed/i)
    ).toBeInTheDocument();
  });

  test('shows email validation callback is produced for invalid email', async () => {
    const { user, setValidationErrors } = renderWithProvider();

    const email = screen.getByLabelText(/requester email/i);
    await user.clear(email);
    await user.type(email, 'not-an-email');

    // component calls setValidationErrors with an updater function
    expect(setValidationErrors).toHaveBeenCalled();
    const updater = setValidationErrors.mock.lastCall[0] as (
      prev: any
    ) => any;

    // Run the updater locally to check shape
    const next = updater({ applicationDetails: {} });
    expect(next.applicationDetails.requesterEmail).toMatch(/invalid email/i);
  });

  test('multi-select "Environments Needed" displays selected values as comma-joined string', () => {
    const fd = makeBaseFormData();
    fd.applicationDetails.environmentsNeeded = ['DEV1', 'SIT'];

    renderWithProvider({ formData: fd });

    // The Select renders a display value via renderValue -> should be in the DOM
    expect(screen.getByText(/DEV1,\s*SIT/i)).toBeInTheDocument();
  });

  test('picks dates via DatePicker and stores ISO strings', async () => {
    const setFormDataSpy = jest.fn();
    const { user } = renderWithProvider({ setFormDataSpy });

    // our DatePicker mock is a plain input labelled with the DatePicker label
    const prod = screen.getByLabelText(/timeline for production/i);

    await user.clear(prod);
    await user.type(prod, '2025-01-12');

    // verify we wrote an ISO-ish string for timelineProd
    const last = setFormDataSpy.mock.lastCall?.[0];
    expect(last).toBeTruthy();
    expect(last.applicationDetails.timelineProd).toMatch(/^2025-01-12/i);
  });

  test('keeps ART Request section safe (no crash) when artRequestDetails is empty arrays', () => {
    const fd = makeBaseFormData();
    fd.applicationDetails.artRequestDetails = {
      Sandbox: [],
      // could include more categories, the point is: arrays, not undefined
    };

    expect(() => renderWithProvider({ formData: fd })).not.toThrow();
  });
});
