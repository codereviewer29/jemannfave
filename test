import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import {
  FormProvider,
  useFormContext,
  initialFormData,
  GlobalFormData,
} from './FormContext';

// ---------- helpers ----------
/** A tiny consumer to read & change the context */
const Probe: React.FC = () => {
  const { formData, setFormData, resetFormData, requiredFields } = useFormContext();

  return (
    <div>
      <div data-testid="trackingStatus">{String(formData.trackingStatus)}</div>
      <div data-testid="envs">{(formData.applicationDetails.environmentsNeeded || []).join(',')}</div>
      <div data-testid="streamRealTime">{String(formData.cdmNextDetails.streamingSourceRealTime)}</div>
      <div data-testid="req-count">{requiredFields.length}</div>

      <button
        onClick={() => {
          const updated: GlobalFormData = {
            ...formData,
            trackingStatus: 'Completed',
            applicationDetails: {
              ...formData.applicationDetails,
              applicationName: 'NewApp',
            },
          };
          setFormData(updated);
        }}
      >
        update
      </button>

      <button onClick={() => resetFormData()}>reset</button>
    </div>
  );
};

const renderWithProvider = (ui: React.ReactElement) =>
  render(<FormProvider>{ui}</FormProvider>);

// ---------- tests ----------
describe('FormContext', () => {
  test('provides initial form data from provider (spot check across shape)', () => {
    renderWithProvider(<Probe />);

    // from initialFormData
    expect(screen.getByTestId('trackingStatus').textContent).toBe('In_Draft');

    // nested array exists with the known defaults
    expect(screen.getByTestId('envs').textContent).toBe('Sandbox,SIT,UAT,Prod');

    // another nested field under cdmNextDetails
    expect(screen.getByTestId('streamRealTime').textContent).toBe('Kafka');

    // required fields are present (we donâ€™t need exact full list here)
    expect(Number(screen.getByTestId('req-count').textContent)).toBeGreaterThan(0);
  });

  test('setFormData updates context', () => {
    renderWithProvider(<Probe />);

    fireEvent.click(screen.getByText('update'));

    // update applied
    expect(screen.getByTestId('trackingStatus').textContent).toBe('Completed');
  });

  test('resetFormData restores initialFormData', () => {
    renderWithProvider(<Probe />);

    // mutate first
    fireEvent.click(screen.getByText('update'));
    expect(screen.getByTestId('trackingStatus').textContent).toBe('Completed');

    // reset back
    fireEvent.click(screen.getByText('reset'));
    expect(screen.getByTestId('trackingStatus').textContent).toBe('In_Draft');

    // also check a nested value snaps back to default
    expect(screen.getByTestId('envs').textContent).toBe(
      initialFormData.applicationDetails.environmentsNeeded.join(',')
    );
  });

  test('useFormContext throws outside of provider', () => {
    // a component that calls the hook without provider
    const Rogue: React.FC = () => {
      useFormContext();
      return null;
    };

    // React Testing Library suppresses errors by default; capture it to assert
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
    expect(() => render(<Rogue />)).toThrow(/must be used within a FormProvider/i);
    consoleSpy.mockRestore();
  });

  test('requiredFields list contains expected keys (sample subset)', () => {
    // read requiredFields through the consumer
    const RequiredProbe: React.FC = () => {
      const { requiredFields } = useFormContext();
      return <div data-testid="required">{requiredFields.join('|')}</div>;
    };

    renderWithProvider(<RequiredProbe />);
    const joined = screen.getByTestId('required').textContent ?? '';

    // Check a few representative keys you showed in the file:
    expect(joined).toMatch(/applicationDetails\.applicationName/);
    expect(joined).toMatch(/applicationDetails\.requesterEmail/);
    expect(joined).toMatch(/applicationDetails\.serviceNowCI/);
    expect(joined).toMatch(/applicationDetails\.dataClassification/);
  });
});
