// src/provision/provision-list.test.tsx
import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';

// ---- module-scoped helpers we can tweak inside tests ----
const makeRequestMock = jest.fn();
const navigateMock = jest.fn();

// Mutable context state for tokens across tests
let ctxState = { githubToken: '', terraformToken: '' };
const setCtxState = (updater: any) => {
  if (typeof updater === 'function') {
    ctxState = { ...ctxState, ...updater(ctxState) };
  } else {
    ctxState = { ...ctxState, ...updater };
  }
};

// ---- mocks for all externals the component imports ----
jest.mock('react-router-dom', () => ({
  // only the thing ProvisionList uses
  useNavigate: () => navigateMock,
}));

jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
}));

// keep dataParsing as identity so our fixtures are already in the final shape
jest.mock('../utils/dataParsing', () => ({
  __esModule: true,
  default: (d: any) => d,
}));

jest.mock('../gcp_oauth/hooks/useAuth', () => ({
  __esModule: true,
  default: () => ({ loading: false, isAuthenticated: true }),
}));

jest.mock('../gcp_oauth/hooks/useConfApi', () => ({
  __esModule: true,
  default: () => ({ API_BASE_ENDPOINT: 'http://api.example.com' }),
}));

// Very light CustomNavigation stub so layout renders
jest.mock('../home/CustomNavigation', () => ({
  __esModule: true,
  default: () => <div data-testid="nav" />,
}));

// Replace the real context hook with a controllable one
jest.mock('./ProvisionContext', () => ({
  __esModule: true,
  useProvisionContext: () => ({
    provisioningData: ctxState,
    setprovisionData: setCtxState, // in case component calls this name
    setProvisionData: setCtxState, // and this is the one in your file
  }),
}));

// Dropdown => make it an HTML <select> that calls onChange with {value,id,label}
jest.mock('../components/dropdown/Dropdown', () => ({
  __esModule: true,
  default: (props: any) => {
    const { options = [], onChange, ...rest } = props;
    const value = (props.value && props.value.value) || '';
    return (
      <select
        aria-label={rest['data-testid'] || 'dropdown'}
        data-testid={rest['data-testid'] || 'dropdown'}
        value={value}
        onChange={(e) => {
          const v = e.target.value;
          const found = options.find((o: any) => o.value === v);
          onChange?.(found || { value: v, id: v, label: String(v) });
        }}
      >
        {options.map((o: any) => (
          <option key={o.value} value={o.value}>
            {o.label ?? o.value}
          </option>
        ))}
      </select>
    );
  },
}));

// The component under test
import ProvisionList from './provision-list';

// ---------- shared fixtures ----------
/**
 * First API: list of (projectid, env_id) pairs; multiple rows per project.
 * NOTE: matches your implementation (projectid/env_id/id).
 */
const appEnvList = [
  { id: 101, projectid: 'abc-999', env_id: 'dev' },
  { id: 101, projectid: 'abc-999', env_id: 'qa' },
  { id: 202, projectid: 'xyz-111', env_id: 'dev' },
];

const validationRowsForABC = [
  {
    app_id: 'abc-999',
    enablementJiraStatus: 'Done',
    actJiraStatus: 'Open',
    Environment: 'dev',
  },
];

const validationRowsForXYZ = [
  {
    app_id: 'xyz-111',
    enablementJiraStatus: 'In Progress',
    actJiraStatus: 'Open',
    Environment: 'dev',
  },
];

// convenience: render + let bootstrap API calls resolve
async function renderPage() {
  // 1st call -> project/env inventory
  makeRequestMock.mockResolvedValueOnce({ data: appEnvList });
  // 2nd call -> auto fetch validation for first project/env
  makeRequestMock.mockResolvedValueOnce({ data: validationRowsForABC });

  render(<ProvisionList />);

  // wait until table data (Provision button) appears to be sure second call finished
  const btn = await screen.findByRole('button', { name: /provision/i });
  expect(btn).toBeInTheDocument();
}

beforeEach(() => {
  jest.clearAllMocks();
  navigateMock.mockReset();
  // tokens missing by default
  ctxState = { githubToken: '', terraformToken: '' };
});

// ===================================================================================

test('loads project/env data, automatically fetches validation details, and renders table', async () => {
  await renderPage();

  // 1) first call = GET /provisions/getAppIdEnvDetails
  await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(2));

  const firstArg = makeRequestMock.mock.calls[0][0];
  expect(firstArg.method).toBe('GET');
  expect(firstArg.endPoints).toBe('/provisions/getAppIdEnvDetails');

  // 2) the second call is a GET to a computed endpoint (string). Just assert basics.
  const secondArg = makeRequestMock.mock.calls[1][0];
  expect(secondArg.method).toBe('GET');
  expect(typeof secondArg.endPoints).toBe('string');
  expect(secondArg.endPoints.length).toBeGreaterThan(0);

  // 3) table headers and row content rendered
  expect(await screen.findByText(/Application Task Validation/i)).toBeInTheDocument();
  expect(screen.getByText(/GCP project task validation/i)).toBeInTheDocument();
  // row action
  expect(screen.getByRole('button', { name: /provision/i })).toBeInTheDocument();
});

test('switching project triggers a fresh validation fetch automatically', async () => {
  await renderPage();

  // API for the next (auto) fetch after project change
  makeRequestMock.mockResolvedValueOnce({ data: validationRowsForXYZ });

  // Change the project dropdown to the other project (xyz-111)
  const projectDd = screen.getByTestId('project-dropdown');
  fireEvent.change(projectDd, { target: { value: 'xyz-111' } });

  // That should trigger a new GET (3rd call)
  await waitFor(() => expect(makeRequestMock).toHaveBeenCalledTimes(3));

  const thirdArg = makeRequestMock.mock.calls[2][0];
  expect(thirdArg.method).toBe('GET');
  expect(typeof thirdArg.endPoints).toBe('string');
});

test('clicking "Provision" opens the token dialog when tokens are missing', async () => {
  await renderPage();

  // Tokens are missing by default (ctxState set in beforeEach)
  fireEvent.click(screen.getByRole('button', { name: /provision/i }));

  // Dialog title text from your file
  expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();

  // dialog explains tokens
  expect(screen.getByText(/Please provide below tokens/i)).toBeInTheDocument();
});

test('clicking "Provision" navigates when both tokens exist', async () => {
  // Give the context tokens before rendering
  ctxState = { githubToken: 'ghp_123', terraformToken: 'tf_456' };

  await renderPage();

  fireEvent.click(screen.getByRole('button', { name: /provision/i }));

  // route uses row values app_id + Environment
  expect(navigateMock).toHaveBeenCalledWith('/provisions/abc-999/dev');
});

test('fills tokens in dialog and submits -> closes path via navigate', async () => {
  await renderPage(); // tokens missing right now

  // open dialog
  fireEvent.click(screen.getByRole('button', { name: /provision/i }));
  expect(await screen.findByText(/Action Required/i)).toBeInTheDocument();

  // fill two textfields by label (exact labels from your DialogContent)
  fireEvent.change(screen.getByLabelText(/Github Token/i), {
    target: { value: 'ghp_token' },
  });
  fireEvent.change(screen.getByLabelText(/Terraform Token/i), {
    target: { value: 'tf_token' },
  });

  // click Submit button in the dialog footer
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  // navigates using row's app/env
  await waitFor(() => expect(navigateMock).toHaveBeenCalledWith('/provisions/abc-999/dev'));
});
