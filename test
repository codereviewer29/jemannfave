// src/sideNavbar/boarding/intake-components/safeRoomIntakeForm.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';

/* ------------------------------ Mocks ------------------------------ */

/**
 * 1) Mock react-router-dom's <Form> so we don't need a data router.
 *    Everything else from the library remains real.
 */
jest.mock('react-router-dom', () => {
  const actual = jest.requireActual('react-router-dom');
  return {
    ...actual,
    Form: ({ children }: { children: React.ReactNode }) => <form>{children}</form>,
  };
});

/**
 * 2) Mock the ./FormContext module the component imports.
 *    We export a Context object (so our tests can provide a Provider)
 *    and the hook (`useFormContext`) that the component calls.
 */
jest.mock('../FormContext', () => {
  // NOTE: the relative path must match the import used by SafeRoomIntakeForm.tsx
  // If your file is in a different folder depth, adjust "../FormContext".
  type Ctx = {
    formData: any;
    setFormData: (u: any) => void;
    requiredFields: string[];
    resetFormData: () => void;
  };

  const React = require('react') as typeof import('react');
  const Context = (React as any).createContext<Ctx | null>(null);

  return {
    __esModule: true,
    FormContext: Context,
    useFormContext: () => {
      const v = React.useContext(Context);
      if (!v) throw new Error('useFormContext used outside Provider in test');
      return v;
    },
    // export anything else the real module exports that your code imports
  };
});

/* pull the mocked context back so we can render with its Provider */
import { FormContext } from '../FormContext';
import SafeRoomIntakeForm from './safeRoomIntakeForm';

/* ------------------------------ Helpers ------------------------------ */

// Testing Library's TextMatch type (string | RegExp | (content,node)=>boolean)
type TextMatch = Parameters<typeof screen.getByLabelText>[0];

/** Open a MUI Select by its label (mouseDown on the input opens the menu) */
const openSelectByLabel = (label: TextMatch) => {
  const input = screen.getByLabelText(label, { selector: 'input' });
  fireEvent.mouseDown(input);
};

/** Build a Provider with the minimal, safe form shape that the component uses */
function withForm(overrides?: Partial<any>) {
  // minimal + correct keys (only keys used inside this component)
  const baseFormData: any = {
    cdpDetails: { versionCDPRequired: '' }, // updated in useEffect based on selection
    safeRoomDetails: { dataLoadRequired: '' }, // bound to the Select
    ...(overrides || {}),
  };

  // updater that supports both object + functional setState shapes
  const setFormData = jest.fn((updater: any) => {
    if (typeof updater === 'function') {
      const next = updater(baseFormData);
      Object.assign(baseFormData, next);
    } else {
      Object.assign(baseFormData, updater);
    }
  });

  const value = {
    formData: baseFormData,
    setFormData,
    requiredFields: [],
    resetFormData: jest.fn(),
  };

  const Provider = ({ children }: { children: React.ReactNode }) => (
    // cast for test-only generic
    (<FormContext as any).Provider value={value}>{children}</FormContext as any).Provider
  );

  return { Provider, setFormData, formData: baseFormData };
}

/* -------------------------------- Tests ------------------------------- */

describe('SafeRoomIntakeForm', () => {
  test('renders overview copy and the Select (smoke)', () => {
    const { Provider } = withForm();
    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    // Headings / copy
    expect(screen.getByText(/Saferoom Overview/i)).toBeInTheDocument();
    // The Select input (by label)
    expect(screen.getByLabelText(/Select the Saferoom Data Load Capability/i)).toBeInTheDocument();
  });

  test('allows selecting "Cloud Storage"', () => {
    const { Provider, setFormData } = withForm();
    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(screen.getByRole('option', { name: /Cloud Storage/i }));

    // setFormData should be called (object or functional) with the next value
    expect(setFormData).toHaveBeenCalled();
    const arg = setFormData.mock.calls.pop()?.[0];
    const next =
      typeof arg === 'function'
        ? arg({ safeRoomDetails: { dataLoadRequired: '' }, cdpDetails: { versionCDPRequired: '' } })
        : arg;

    expect(next.safeRoomDetails.dataLoadRequired.toLowerCase()).toBe('cloud storage');
  });

  test('allows selecting "Big Query" and sets versionCDPRequired via useEffect', () => {
    const { Provider, setFormData, formData } = withForm();
    render(
      <Provider>
        <SafeRoomIntakeForm validationErrors={{}} />
      </Provider>
    );

    openSelectByLabel(/Select the Saferoom Data Load Capability/i);
    fireEvent.click(screen.getByRole('option', { name: /Big Query/i }));

    // First update: safeRoomDetails.dataLoadRequired
    expect(setFormData).toHaveBeenCalled();

    // Simulate the internal useEffect: when dataLoadRequired changes,
    // component sets cdpDetails.versionCDPRequired to the friendly label
    // (you do exactly that in your useEffect)
    // Our withForm updater has already merged, so assert on the live object.
    expect(
      (formData.safeRoomDetails.dataLoadRequired || '').toLowerCase()
    ).toBe('big query');

    // Now it should have set cdpDetails.versionCDPRequired accordingly
    expect(formData.cdpDetails.versionCDPRequired).toMatch(/Big Query|Cloud Storage|BQ to BQ version/i);
  });

  test('shows validation error styling when provided', () => {
    const { Provider } = withForm({ safeRoomDetails: { dataLoadRequired: '' } });

    render(
      <Provider>
        <SafeRoomIntakeForm
          validationErrors={{ safeRoomDetails: { dataLoadRequired: 'Required field' } } as any}
        />
      </Provider>
    );

    // MUI Select reflects error via aria-invalid on the input
    const selectInput = screen.getByLabelText(/Select the Saferoom Data Load Capability/i, {
      selector: 'input',
    });
    expect(selectInput).toHaveAttribute('aria-invalid', 'true');
  });
});
