// path: src/inventory/__tests__/Inventory.test.tsx
/**
 * Minimal, focused tests for Inventory.tsx
 * - Uses Jest + React Testing Library
 * - Heavily mocks external dependencies to hit logic branches
 */

import React from 'react';
import { render, screen, waitFor, fireEvent, within } from '@testing-library/react';
import '@testing-library/jest-dom';

// --- Mocks for 3rd-party + app dependencies that Inventory.tsx imports ---

// 1) Mock react-router-dom hooks used inside the component
const mockNavigate = jest.fn();
let mockLocationState: any = null;

jest.mock('react-router-dom', () => ({
  // Only the hooks/exports that Inventory.tsx uses
  useNavigate: () => mockNavigate,
  useLocation: () => ({ state: mockLocationState }),
  useParams: () => ({}),
}));

// 2) Mock the API hook: useAPIService -> returns makeRequest
//    Return different payloads based on the request.endpoints string
const makeRequestSpy = jest.fn();

jest.mock('../../services/useAPIService', () => ({
  __esModule: true,
  default: () =>
    ((req: { endpoints: string }) => makeRequestSpy(req)) as unknown,
}));

// 3) Mock the LANE_ORDER constant used by getLaneData
jest.mock('../../constants/inventory-constants', () => ({
  LANE_ORDER: ['L1', 'L2', 'L3', 'L4'],
}));

// 4) Mock non-essential heavy UI children to keep tests deterministic
jest.mock('../../components/TreeView/Tree-View', () => ({
  __esModule: true,
  default: ({ tabname }: { tabname: string }) => (
    <div data-testid={`tree-view-${tabname}`} />
  ),
}));

jest.mock(
  '../../components/ApplicationVersion/Application-Version',
  () => ({
    __esModule: true,
    default: ({ tabname }: { tabname: string }) => (
      <div data-testid={`app-version-${tabname}`} />
    ),
  })
);

// 5) Replace local DropDown with a minimal select. We keep the same props API:
//    - value: OptionType | null
//    - options: OptionType[]
//    - onChange: (opt) => void
//    - data-testid: string (exists in your code)
type OptionType = { id: number; value: string; label: string };
function MockDropDown({
  value,
  options,
  onChange,
  'data-testid': testId,
}: {
  value: OptionType | null;
  options: OptionType[];
  onChange: (opt: OptionType) => void;
  'data-testid': string;
}) {
  return (
    <select
      data-testid={testId}
      value={value?.value ?? ''}
      onChange={(e) => {
        const opt = options.find((o) => o.value === e.target.value);
        if (opt) onChange(opt);
      }}
    >
      <option value="" aria-label="empty" />
      {options.map((o) => (
        <option key={`${o.id}-${o.value}`} value={o.value}>
          {o.label}
        </option>
      ))}
    </select>
  );
}

// NOTE: Make sure the path below matches your real import in Inventory.tsx
jest.mock('../../components/DropDown/DropDown', () => ({
  __esModule: true,
  default: MockDropDown,
}));

// If your path differs (e.g. '../../components/dropdown/Dropdown' or similar),
// duplicate another jest.mock with the exact path used in your file.

// 6) (Optional) If MUI theming causes noise, stub useTheme to a simple object
jest.mock('@mui/material/styles', () => ({
  useTheme: () => ({ direction: 'ltr' }),
}));

// --- Test data fixtures ---

const PROJECT_ENV_ROWS = [
  // app1 has two envs and lanes
  { projectid: 'app1', prj_env_id: 10, env_id: 'dev', env_lane: 'L2' },
  { projectid: 'app1', prj_env_id: 11, env_id: 'qa',  env_lane: 'L1' },
  // app2 single env
  { projectid: 'app2', prj_env_id: 20, env_id: 'dev', env_lane: 'L3' },
];

const COMPONENTS_PAYLOAD = {
  data: {
    component_response: [
      { component_type: 'service', name: 'svc-a' },
      { component_type: 'google_storage_bucket_object', name: 'skip-me' }, // filtered out
    ],
  },
};

const SAFEROOM_PAYLOAD = {
  data: {
    saferoom_response: [
      { component_type: 'infra', name: 'sg-a' },
      { component_type: 'google_storage_bucket_object', name: 'skip-me-too' }, // filtered out
    ],
  },
};

const VERSION_PAYLOAD = {
  data: {
    cdp_cdp_version_response: [{ artifact: 'a', version: '1.2.3' }],
  },
};

// Default handler for makeRequestSpy (can be overridden per-test)
function primeHappyApi() {
  makeRequestSpy.mockImplementation(({ endpoints }) => {
    if (endpoints.includes('getInventoryEnvProject')) {
      return Promise.resolve({ data: PROJECT_ENV_ROWS });
    }
    if (endpoints.includes('getTenantAppCompDetails')) {
      return Promise.resolve(COMPONENTS_PAYLOAD);
    }
    if (endpoints.includes('getTenantAppCompSafeRoomDetails')) {
      return Promise.resolve(SAFEROOM_PAYLOAD);
    }
    if (endpoints.includes('getTenantAppVersionDetails')) {
      return Promise.resolve(VERSION_PAYLOAD);
    }
    return Promise.resolve({ data: {} });
  });
}

// SUT import after mocks
import Inventory from '../Inventory';

// Small helper
const flush = () => new Promise((r) => setTimeout(r, 0));

describe('Inventory', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockLocationState = null;
  });

  test('renders tabs with a11y attributes and loads projects', async () => {
    primeHappyApi();

    render(<Inventory />);

    // Tabs (labels taken from your screenshots)
    const tabLabels = ['GCP APP', 'GCP SAFEROOM', 'CDP', 'SAFEROOM', 'CDM Next'];
    tabLabels.forEach((label) => {
      expect(screen.getByRole('tab', { name: label })).toBeInTheDocument();
    });

    // a11y ids (indirect coverage of a11yProps)
    const allTabs = screen.getAllByRole('tab');
    allTabs.forEach((tab, idx) => {
      expect(tab).toHaveAttribute('id', `full-width-tab-${idx}`);
      // Panels are created later; assert at least first panel appears after render
    });

    // Initial project fetch populates project dropdown
    const projectDd = await screen.findByTestId('project-dropdown');
    const options = within(projectDd).getAllByRole('option');
    // empty + 2 unique projects = 3
    expect(options.length).toBe(3);
    expect(options.map((o) => (o as HTMLOptionElement).text)).toEqual(
      expect.arrayContaining(['APP1', 'APP2'])
    );
  });

  test('selecting project then lane triggers handleSubmit and parallel fetches', async () => {
    primeHappyApi();

    render(<Inventory />);

    const projectDd = await screen.findByTestId('project-dropdown');

    // Select app1; this should populate envs and then lanes (sorted by LANE_ORDER)
    fireEvent.change(projectDd, { target: { value: 'app1' } });
    await flush();

    const laneDd = await screen.findByTestId('lane-dropdown');

    // app1 has lanes L2 and L1; they must be sorted by LANE_ORDER => L1, L2
    const laneOptions = within(laneDd).getAllByRole('option');
    const laneLabels = laneOptions.map((o) => (o as HTMLOptionElement).text);
    expect(laneLabels).toEqual(expect.arrayContaining(['L1', 'L2']));

    // Choose L1; with project + env known, this should call 3 endpoints
    fireEvent.change(laneDd, { target: { value: 'L1' } });

    await waitFor(() => {
      expect(makeRequestSpy).toHaveBeenCalledWith(
        expect.objectContaining({ endpoints: expect.stringContaining('getTenantAppCompDetails') })
      );
      expect(makeRequestSpy).toHaveBeenCalledWith(
        expect.objectContaining({ endpoints: expect.stringContaining('getTenantAppCompSafeRoomDetails') })
      );
      expect(makeRequestSpy).toHaveBeenCalledWith(
        expect.objectContaining({ endpoints: expect.stringContaining('getTenantAppVersionDetails') })
      );
    });

    // TabPanels exist; only current (index 0 by default) is visible
    const panel0 = screen.getByRole('tabpanel', { hidden: true });
    expect(panel0).toHaveAttribute('id', 'full-width-tabpanel-0');
  });

  test('uses location.state to auto-select and submit only once', async () => {
    primeHappyApi();

    // Provide tenant/env/lane via navigation state to hit that useEffect branch
    mockLocationState = { tenant: 'app2', env: 'dev', lane: 'L3' };

    render(<Inventory />);
    await waitFor(() => {
      // One set of 3 parallel calls should have fired
      const versionCalls = makeRequestSpy.mock.calls.filter((c) =>
        String(c[0]?.endpoints || '').includes('getTenantAppVersionDetails')
      );
      expect(versionCalls.length).toBe(1);
    });
  });

  test('empty project list branch: shows empty dropdowns and logs error', async () => {
    // Make project list empty to trigger else-branch in processProjectData
    makeRequestSpy.mockImplementation(({ endpoints }) => {
      if (endpoints.includes('getInventoryEnvProject')) {
        return Promise.resolve({ data: [] });
      }
      return Promise.resolve({ data: {} });
    });

    const errSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

    render(<Inventory />);

    const projectDd = await screen.findByTestId('project-dropdown');
    const options = within(projectDd).getAllByRole('option');
    // only the empty placeholder
    expect(options.length).toBe(1);

    expect(errSpy).toHaveBeenCalled(); // "No project IDs found in the data" path
    errSpy.mockRestore();
  });

  test('tab switching hides and shows panels appropriately', async () => {
    primeHappyApi();

    render(<Inventory />);

    const tabGcpSaferoom = screen.getByRole('tab', { name: 'GCP SAFEROOM' });
    fireEvent.click(tabGcpSaferoom);

    // After switching, a second panel should be present (hidden=false for index 1)
    // Using hidden: true to query all and check `hidden` attribute value
    const allPanels = screen.getAllByRole('tabpanel', { hidden: true });

    // panel-1 should exist; ensure one of them has id/index for 1
    const hasPanel1 = allPanels.some(
      (p) => p.getAttribute('id') === 'full-width-tabpanel-1' && p.getAttribute('hidden') === null
    );
    expect(hasPanel1).toBeTruthy();
  });
});
