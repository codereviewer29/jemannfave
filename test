// src/sideNavbar/boarding/applicationDetails.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor, within } from '@testing-library/react';

/* ----------------------------- External mocks ----------------------------- */

// DatePicker: render a bare input that calls onChange when clicked
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  __esModule: true,
  DatePicker:
    ({ label, onChange }: any) => (
      <input
        data-testid="mock-date"
        aria-label={label}
        onClick={() => onChange?.('2025-01-01' as any)}
      />
    ),
}));

// dayjs adapter not needed in tests
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  __esModule: true,
  LocalizationProvider: ({ children }: any) => <>{children}</>,
}));

// Services used by the component
const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

const saveActIntake = jest.fn();
const saveGcpIntakeFinal = jest.fn();
jest.mock('../../services/gcpIntakeOnboardingService', () => ({
  __esModule: true,
  default: {
    saveActIntake: (...args: any[]) => saveActIntake(...args),
    saveGcpIntakeFinal: (...args: any[]) => saveGcpIntakeFinal(...args),
  },
}));

/* --------------------------- Mock FormContext hook ------------------------- */

// The component uses useFormContext(). We’ll supply our own Provider + value.
let ctxValueRef: any = null;

jest.mock('./FormContext', () => {
  const React = require('react');
  const Context = React.createContext<any>(null);

  return {
    __esModule: true,
    // context (for our Provider)
    FormContext: Context,
    // hook consumed by the component
    useFormContext: () => {
      const v = React.useContext(Context);
      if (!v) throw new Error('useFormContext used outside Provider in test');
      ctxValueRef = v;
      return v;
    },
    // also export the real initial so keys exist
    initialFormData: require('./FormContext').initialFormData,
  };
});

/* --------------------------------- SUT ------------------------------------ */

import ApplicationDetails from './applicationDetails';

/* ------------------------------- Test helpers ----------------------------- */

// Accept Testing Library's TextMatch (string | RegExp | function)
type TextMatch = Parameters<typeof screen.getByLabelText>[0];

// Type into a text input/textarea. Uses accessible name to find control.
const typeIn = (name: RegExp | string, text: string) => {
  const el =
    screen.getByRole('textbox', { name }) as HTMLInputElement | HTMLTextAreaElement;
  const nameAttr = el.getAttribute('name') || '';
  fireEvent.change(el, { target: { name: nameAttr, value: text } });
};

// Open a MUI Select by its visible label (button role)
const openSelectByButtonName = (name: RegExp | string) => {
  const button = screen.getByRole('button', { name });
  fireEvent.mouseDown(button);
};

// Click the end‑adornment button next to an input (e.g., search icon for App ID)
const clickEndAdornmentButton = (name: RegExp | string) => {
  const textbox = screen.getByRole('textbox', { name });
  // go up to the OutlinedInput root and find the first button in the adornment
  const root = textbox.closest('.MuiFormControl-root') || textbox.parentElement!;
  const btn = root.querySelector('button') as HTMLButtonElement | null;
  if (!btn) throw new Error('End‑adornment button not found');
  fireEvent.click(btn);
};

/* ------------------------------- Test setup -------------------------------- */

function withForm(overrides?: Partial<any>) {
  // minimal, safe formData the component reads/writes
  const baseFormData = {
    applicationDetails: {
      applicationID: '',
      applicationName: '',
      summary: '',
      description: '',
      purposeAndBenefit: '',
      lobDomain: '',
      environmentsNeeded: [] as string[],
      requesterName: '',
      requesterEmail: '',
      businessExecutiveSponsor: '',
      applicationBusinessOwner: '',
      applicationPortfolioOwner: '',
      techExecutiveSponsor: '',
      primaryTechManager: '',
      cloudAccountableExecutive: '',
      applicationArchitect: '',
      auNumber: '',
      techContact: '',
      dmiCloudContact: '',
      serviceNowSupportGroup: '',
      applicationOwnerApprover: '',
      timelineSandbox: null as any,
      timelineNonProd: null as any,
      timelineProd: null as any,
      dataSource: 'External',
      dataFormat: [] as string[],
      dataSLATime: '',
      dataClassification: '',
      panCardDataInScope: '',
      panCardDetails: '',
      sarUarData: '',
      internationalUsers: '',
      externalIngress: '',
      externalIngressDetails: '',
      serviceNowCI: '',
      technicalConstraints: '',
      reviewedWithCIO: '',
      reviewedWithArchitect: '',
      requiresCloudReview: '',
      appLinkBAN: '',
      beamsStatus: '',
      applicationLocation: '',
    },
    actDetails: {},
  };

  const setFormData = jest.fn((updater: any) => {
    // support functional updates like the real setter
    if (typeof updater === 'function') {
      const next = updater(baseFormData);
      Object.assign(baseFormData, next);
    } else {
      Object.assign(baseFormData, updater);
    }
  });

  const value = {
    formData: { ...baseFormData, ...(overrides || {}) },
    setFormData,
    requiredFields: [],
    resetFormData: jest.fn(),
  };

  const Provider = ({ children }: { children: React.ReactNode }) => (
    <(_FormContext.Provider as any) value={value}>{children}</(_FormContext.Provider>
  );

  return { Provider, setFormData };
}

// Pull the mocked context back out (exported from our jest.mock above)
const { FormContext: _FormContext } = jest.requireMock('./FormContext');

/* --------------------------------- Tests ----------------------------------- */

describe('ApplicationDetails (lite)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders Overview + a few core fields', () => {
    const { Provider } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Use role queries that are unique
    expect(screen.getByRole('textbox', { name: /Application ID/i })).toBeInTheDocument();
    expect(screen.getByRole('textbox', { name: /^Summary$/i })).toBeInTheDocument();
    expect(screen.getByRole('textbox', { name: /Purpose and Benefit/i })).toBeInTheDocument();
    // MUI Select label shows as a button/combobox
    expect(screen.getByRole('button', { name: /Environments Needed/i })).toBeInTheDocument();
  });

  test('typing in Summary updates form via setFormData (text handler)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn(/^Summary$/, 'hello');
    expect(setFormData).toHaveBeenCalled();
  });

  test('changing AU Number triggers number handler', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    typeIn(/AU Number/i, '12345');
    expect(setFormData).toHaveBeenCalled();
  });

  test('Environments Needed (multi-select) triggers setFormData', async () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    openSelectByButtonName(/Environments Needed/i);

    // choose a couple of options that exist in your TSX
    fireEvent.click(await screen.findByRole('option', { name: /SIT/i }));
    fireEvent.click(await screen.findByRole('option', { name: /UAT/i }));

    // Close popover: Escape
    fireEvent.keyDown(document.body, { key: 'Escape' });

    expect(setFormData).toHaveBeenCalled();
  });

  test('date pickers call handler without crashing (Sandbox timeline)', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    fireEvent.click(screen.getByTestId('mock-date')); // our DatePicker mock
    expect(setFormData).toHaveBeenCalled();
  });

  test('radio groups call handler → data classification "Public"', () => {
    const { Provider, setFormData } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Most reliable for MUI radios is label text
    const publicRadio = screen.getByLabelText(/Public/i);
    fireEvent.click(publicRadio);
    expect(setFormData).toHaveBeenCalled();
  });

  test('typing requester email validates format (invalid → helper via setValidationErrors)', () => {
    const setValidationErrors = jest.fn();
    const { Provider } = withForm();

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={setValidationErrors} />
      </Provider>
    );

    typeIn(/Requester Email/i, 'not-an-email');

    // The component uses updater function; assert it and execute to verify merge
    expect(setValidationErrors).toHaveBeenCalled();
    const updater = setValidationErrors.mock.calls[0][0];
    expect(typeof updater).toBe('function');
    const merged = updater({}); // simulate prev = {}
    expect(merged).toEqual(
      expect.objectContaining({
        applicationDetails: expect.objectContaining({
          requesterEmail: expect.stringMatching(/invalid email/i),
        }),
      })
    );
  });

  test('search by App ID triggers both services and may open the toaster (happy path)', async () => {
    const { Provider, setFormData } = withForm();

    // 1) BAM details
    makeRequest
      .mockResolvedValueOnce({ data: { applicationID: 'APP123', applicationName: 'My App' }, status: 200 })
      // 2) env validation API
      .mockResolvedValueOnce({ data: { environments: ['SIT'] }, status: 200 });

    render(
      <Provider>
        <ApplicationDetails validationErrors={{}} setValidationErrors={jest.fn()} />
      </Provider>
    );

    // Enter App ID then click the adornment search button
    typeIn(/Application ID/i, 'APP123');
    clickEndAdornmentButton(/Application ID/i);

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(2));
    expect(setFormData).toHaveBeenCalled(); // patched with BAM details + envs
  });
});
