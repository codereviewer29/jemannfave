import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// --------- Component under test ----------
import ApplicationDetails from './applicationDetails';

// --------- A mutable context value the hook will return ----------
let ctxValue: any;

// Mock the FormContext hook only (no Provider JSX = no TS JSX errors)
jest.mock('./FormContext', () => ({
  useFormContext: () => ctxValue,
}));

// --------- Minimal, robust mocks for MUI X date pickers ----------
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => ({
  AdapterDayjs: class AdapterDayjs {},
}));

jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  LocalizationProvider: ({ children }: any) => <div>{children}</div>,
}));

// Render a plain input that calls the provided onChange with the typed string.
// Our component takes the value and converts via dayjs(date).toISOString().
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  DatePicker: ({ label, value, onChange }: any) => (
    <input
      aria-label={label}
      value={value ?? ''}
      onChange={(e) => onChange?.(e.target.value)}
    />
  ),
}));

// --------- API hook mock so we can assert calls & return data ----------
const makeRequestMock = jest.fn();
jest.mock('../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest: makeRequestMock }),
  // some code may import named as well:
  useApiService: () => ({ makeRequest: makeRequestMock }),
}));

// --------- Helpers ----------
function makeBaseFormData(overrides: Partial<any> = {}) {
  return {
    applicationDetails: {
      applicationID: '',
      applicationName: '',
      summary: '',
      description: '',
      purposeAndBenefit: '',
      lobDomain: '',
      environmentsNeeded: [],
      requesterName: '',
      requesterEmail: '',
      timelineSandbox: null,
      timelineNonProd: null,
      timelineProd: null,
      isNewApp: '',
      appLocation: '',
      appLinkInBAM: '',
      beamsStatus: '',
      dataSource: '',
      dataFormat: [],
      dataSLATime: '',
      dataClassification: '',
      panCardDataInScope: '',
      panCardDetails: '',
      sarUarData: '',
      internationalUsers: '',
      externalIngress: '',
      externalIngressDetails: '',
      serviceNowCI: '',
      technicalConstraints: '',
      reviewedWithCIO: '',
      reviewedWithArchitect: '',
      requiresCloudReview: '',
      // ...add more as your tests need
      ...overrides,
    },
    // other slices used by setFormData mirroring screenshots:
    actDetails: {},
  };
}

function renderWithCtx(opts?: {
  formData?: any;
  setFormDataSpy?: jest.Mock;
  validation?: any;
}) {
  const user = userEvent.setup();
  const formData = opts?.formData ?? makeBaseFormData();
  const setFormData = opts?.setFormDataSpy ?? jest.fn();

  // value returned by useFormContext
  ctxValue = { formData, setFormData };

  const validationErrors = opts?.validation ?? { applicationDetails: {} };
  const setValidationErrors = jest.fn();

  render(
    <ApplicationDetails
      validationErrors={validationErrors}
      setValidationErrors={setValidationErrors}
    />
  );

  return { user, formData, setFormData, setValidationErrors };
}

// ============== TESTS =================

describe('ApplicationDetails', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders key fields and headings', () => {
    renderWithCtx();

    // A few representative labels visible in your screenshots
    expect(screen.getByLabelText(/Application ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Application Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/^Summary$/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Description/i)).toBeInTheDocument();
    expect(screen.getByText(/Overview/i)).toBeInTheDocument();
    expect(screen.getByText(/Points of Contact/i)).toBeInTheDocument();
    expect(screen.getByText(/Timing Section/i)).toBeInTheDocument();
  });

  test('shows email validation message for invalid email', async () => {
    const { user } = renderWithCtx();

    const email = screen.getByLabelText(/Requester Email/i) as HTMLInputElement;
    await user.clear(email);
    await user.type(email, 'bad-email');

    // component sets validationErrors.applicationDetails.requesterEmail = 'Invalid email format'
    expect(screen.getByText(/Invalid email format/i)).toBeInTheDocument();
  });

  test('clicking search icon on Application ID triggers BAM fetch', async () => {
    const { user } = renderWithCtx();

    // enter an Application ID
    const appId = screen.getByLabelText(/Application ID/i) as HTMLInputElement;
    await user.clear(appId);
    await user.type(appId, 'APP123');

    // Click the icon button wired to handleAppIdChange
    // There is only one IconButton in the "Application ID" InputAdornment area, so query by role
    const searchBtn = screen.getAllByRole('button').find((b) =>
      /search/i.test(b.innerHTML) || b.getAttribute('aria-label')?.match(/search/i)
    ) ?? screen.getAllByRole('button')[0];

    await user.click(searchBtn);

    // the component calls makeRequest('/api/application-details/bam-data?appid=...')
    expect(makeRequestMock).toHaveBeenCalled();
    const arg = makeRequestMock.mock.calls[0][0];
    expect(arg).toEqual(
      expect.objectContaining({
        method: 'GET',
        endpoints: expect.stringMatching(/bam-data\?appid=APP123/i),
      })
    );
  });

  test('multi-select "Environments Needed" displays selected values as comma-joined string', async () => {
    const fm = makeBaseFormData({
      environmentsNeeded: ['Sandbox'],
    });
    const { user, setFormData } = renderWithCtx({ formData: fm });

    // The select is labeled "Environments Needed"
    const select = screen.getByLabelText(/Environments Needed/i);

    // Our component uses <Select multiple> – in tests we simulate by firing change with array-like value
    // but since we don’t render the real MUI <Select>, we’ll update via onChange handler using native input
    // Try a simple change to add more values (simulate DEV1, UAT)
    fireEvent.change(select, { target: { value: ['Sandbox', 'DEV1', 'UAT'] } });

    // The component custom-renderValue joins with ", "
    // We can assert setFormData received updated list
    expect(setFormData).toHaveBeenCalledWith(
      expect.objectContaining({
        applicationDetails: expect.objectContaining({
          environmentsNeeded: ['Sandbox', 'DEV1', 'UAT'],
        }),
      })
    );
  });

  test('picks dates via DatePicker and stores ISO strings', async () => {
    const { user, setFormData } = renderWithCtx();

    // The mocked DatePicker renders as an <input aria-label="Timeline for Sandbox">
    const sandbox = screen.getByLabelText(/Timeline for Sandbox/i);
    await user.clear(sandbox);
    await user.type(sandbox, '2025-01-12');

    // the component calls setFormData with ISO-ish conversion via dayjs(date).toISOString()
    // We only verify that setFormData was called with a stringy value
    expect(setFormData).toHaveBeenCalledWith(
      expect.objectContaining({
        applicationDetails: expect.objectContaining({
          timelineSandbox: expect.any(String),
        }),
      })
    );
  });
});
