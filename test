import { renderHook, waitFor } from '@testing-library/react';
import useAuth from './hooks/useAuth';
import axios from 'axios';

// ---- mock the JSON env relative to *this test file* ----
const BASE = 'https://api.example.com';
jest.mock('../assets/json/env-properties.json', () => ({
  API_BASE_ENDPOINT: BASE,
}));

// ---- mock axios default import ----
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('useAuth', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('calls /auth/user with credentials and sets isAuthenticated=true on success', async () => {
    mockedAxios.get.mockResolvedValueOnce({ data: { isAuthenticated: true } });

    const { result } = renderHook(() => useAuth());

    // initial state
    expect(result.current.loading).toBe(true);
    expect(result.current.isAuthenticated).toBe(false);

    // axios called correctly
    await waitFor(() =>
      expect(mockedAxios.get).toHaveBeenCalledWith(
        `${BASE}/auth/user`,
        { withCredentials: true }
      )
    );

    // final state
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.isAuthenticated).toBe(true);
    });
  });

  test('sets isAuthenticated=false when API returns false', async () => {
    mockedAxios.get.mockResolvedValueOnce({ data: { isAuthenticated: false } });

    const { result } = renderHook(() => useAuth());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.isAuthenticated).toBe(false);
    });
  });

  test('sets isAuthenticated=false when request fails', async () => {
    mockedAxios.get.mockRejectedValueOnce(new Error('network error'));

    const { result } = renderHook(() => useAuth());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.isAuthenticated).toBe(false);
    });
  });
});
