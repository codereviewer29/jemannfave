// File: src/intake-components/__tests__/CDPIntakeForm.test.tsx
import React from 'react';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// Mock router <Form> to a plain form so onSubmit fires normally
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  Form: ({ children, onSubmit }: { children: React.ReactNode; onSubmit?: React.FormEventHandler }) => (
    <form onSubmit={onSubmit}>{children}</form>
  ),
}));

// Inline Tooltip title to avoid portals/hover
jest.mock('@mui/material', () => {
  const actual = jest.requireActual('@mui/material');
  return {
    ...actual,
    Tooltip: ({ title, children }: { title: React.ReactNode; children: React.ReactElement }) => (
      <div>
        <div data-testid="tooltip-title">{title}</div>
        {children}
      </div>
    ),
  };
});

// --- Mock FormContext used by the component ---
let ctxFormData: any;
let ctxSetFormData: jest.Mock;
let ctxSetReadOnly: jest.Mock;

jest.mock('../FormContext', () => ({
  useFormContext: () => ({
    formData: ctxFormData,
    setFormData: ctxSetFormData,
    setReadOnly: ctxSetReadOnly,
  }),
}));

// Import after mocks
import CDPIntakeForm from '../cdpIntakeForm';

// --- Helpers ---
function resetCtx(overrides?: Partial<any>) {
  ctxFormData = {
    cdpDetails: { versionCDPRequired: '' },
    safeRoomDetails: { dataLoadRequired: '' },
    ...(overrides ?? {}),
  };
  ctxSetReadOnly = jest.fn();
  ctxSetFormData = jest.fn((next: any) => {
    ctxFormData = typeof next === 'function' ? next(ctxFormData) : next;
  });
}

function renderForm(validationErrors: Record<string, boolean> = {}) {
  return render(<CDPIntakeForm validationErrors={validationErrors} />);
}

// --- Tests ---
describe('CDPIntakeForm', () => {
  beforeEach(() => resetCtx());

  test('renders overview, label, tooltip text, and shows disabled select', () => {
    const { container } = renderForm();

    expect(screen.getByText(/CDP Overview/i)).toBeInTheDocument();
    expect(
      screen.getByText(/Cloud Data pipeline \(CDP\) Framework streamlines and accelerates Cloud migration/i)
    ).toBeInTheDocument();

    // Label + disabled select
    const select = screen.getByRole('combobox', {
      name: /Which version of CDP is required/i,
    });
    expect(select).toBeDisabled();

    // Tooltip/help content
    const tip = screen.getByTestId('tooltip-title');
    expect(within(tip).getByText(/Cloud Storage: Both inbound and outbound data are handled as files/i)).toBeInTheDocument();
    expect(within(tip).getByText(/Big Query: Inbound data is handled as files/i)).toBeInTheDocument();

    // Snapshot to pad coverage
    expect(container).toMatchSnapshot();
  });

  test('useEffect maps Cloud Storage → File to BQ version', () => {
    resetCtx({ safeRoomDetails: { dataLoadRequired: 'Cloud Storage' } });
    renderForm();
    expect(ctxFormData.cdpDetails.versionCDPRequired).toBe('File to BQ version');
  });

  test('useEffect maps Big Query → BQ to BQ version', () => {
    resetCtx({ safeRoomDetails: { dataLoadRequired: 'Big Query' } });
    renderForm();
    expect(ctxFormData.cdpDetails.versionCDPRequired).toBe('BQ to BQ version');
  });

  test('validationErrors prop marks select invalid', () => {
    renderForm({ versionCDPRequired: true });

    const select = screen.getByRole('combobox', {
      name: /Which version of CDP is required/i,
    });
    // MUI forwards error to input as aria-invalid
    expect(select).toHaveAttribute('aria-invalid', 'true');
  });

  test('Save success: shows success alert and disables actions', async () => {
    const user = userEvent.setup();
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    // Pre-populate required field
    resetCtx({ cdpDetails: { versionCDPRequired: 'File to BQ version' } });

    renderForm();

    await user.click(screen.getByRole('button', { name: /^Save$/i }));

    expect(screen.getByText(/Saferoom Intake details saved Successfully/i)).toBeInTheDocument();
    // Read-only state after save disables buttons
    expect(screen.getByRole('button', { name: /^Save$/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /Cancel/i })).toBeDisabled();
    expect(logSpy).toHaveBeenCalled(); // confirms success branch executed
    logSpy.mockRestore();
  });

  test('Save with missing field shows validation error alert', async () => {
    const user = userEvent.setup();
    resetCtx({ cdpDetails: { versionCDPRequired: '' } });
    renderForm();

    await user.click(screen.getByRole('button', { name: /^Save$/i }));

    expect(
      screen.getByText(/Please complete all required fields before saving/i)
    ).toBeInTheDocument();
  });

  test('Cancel logs and does not crash', async () => {
    const user = userEvent.setup();
    const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    renderForm();

    await user.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(logSpy).toHaveBeenCalledWith('Form cancelled');
    logSpy.mockRestore();
  });
});
