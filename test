// applicationDetails.test.tsx
import React, { useState } from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ApplicationDetails from './applicationDetails';

// ---- Mock FormContext: export a Provider we can use in tests + the hook the component imports
jest.mock('../FormContext', () => {
  const React = require('react');
  const Ctx = React.createContext<any>(null);
  return {
    __esModule: true,
    // Hook used by the component
    useFormContext: () => React.useContext(Ctx),
    // Provider we will use in the tests
    TestFormProvider: ({ value, children }: any) => (
      <Ctx.Provider value={value}>{children}</Ctx.Provider>
    ),
  };
});
import { TestFormProvider } from '../FormContext';

// ---- Minimal, robust mocks for MUI X date pickers
jest.mock('@mui/x-date-pickers/AdapterDayjs', () => function AdapterDayjs() { return null; });
jest.mock('@mui/x-date-pickers/LocalizationProvider', () => ({
  LocalizationProvider: ({ children }: any) => <div>{children}</div>,
}));
jest.mock('@mui/x-date-pickers/DatePicker', () => ({
  DatePicker: ({ label, value, onChange }: any) => (
    <input
      aria-label={label}
      value={value ?? ''}
      onChange={(e) => onChange?.(e.target.value)}
    />
  ),
}));

// ---- API service is not exercised here
jest.mock('../../services/useApiService', () => () => ({
  makeRequest: jest.fn(),
}));

// ---- Base formData shape
const makeBaseFormData = () => ({
  applicationDetails: {
    applicationID: '',
    applicationName: '',
    summary: '',
    description: '',
    purposeAndBenefit: '',
    lobDomain: '',
    environmentsNeeded: [] as string[],
    requesterName: '',
    requesterEmail: '',
    businessExecutiveSponsor: '',
    applicationBusinessOwner: '',
    applicationPortfolioOwner: '',
    techExecutiveSponsor: '',
    primaryTechManager: '',
    cloudAccountableExecutive: '',
    applicationArchitect: '',
    auNumber: '',
    techContact: '',
    dmiCloudContact: '',
    serviceNowSupportGroup: '',
    developersList: '',
    applicationOwnerApprover: '',
    timelineSandbox: null as any,
    timelineNonProd: null as any,
    timelineProd: null as any,
    isNewApp: '',
    application: '',
    appLinkInBAM: '',
    beamsStatus: '',
    dataSource: '',
    dataFormat: [] as string[],
    dataSLATime: '',
    dataClassification: '',
    panCardDataInScope: '',
    panCardDetails: '',
    sarUarData: '',
    internationalUsers: '',
    externalIngress: '',
    externalIngressDetails: '',
    serviceNowCI: '',
    technicalConstraints: '',
    artRequestDetails: {
      sandbox: [{ label: 'Request number', value: '', isCustom: false }],
    } as Record<string, Array<{ label: string; value: string; isCustom?: boolean }>>,
  },
  actDetails: {},
});

function Host() {
  const [formData, setFormData] = useState(makeBaseFormData());
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
  const value = { formData, setFormData };
  return (
    <TestFormProvider value={value}>
      <ApplicationDetails
        validationErrors={validationErrors}
        setValidationErrors={setValidationErrors}
      />
    </TestFormProvider>
  );
}

function renderApp() {
  const user = userEvent.setup();
  render(<Host />);
  return { user };
}

describe('ApplicationDetails', () => {
  test('renders key sections and fields', () => {
    renderApp();

    expect(screen.getByLabelText(/Application ID/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Application Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/^Summary$/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/^Description$/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Purpose and Benefit/i)).toBeInTheDocument();

    expect(screen.getByRole('button', { name: /Environments Needed/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /List of Data Format/i })).toBeInTheDocument();

    expect(screen.getByLabelText(/LOB Domain\/CTO/i)).toBeDisabled();
  });

  test('typing updates controlled fields (Application Name, Summary)', async () => {
    const { user } = renderApp();

    const appName = screen.getByLabelText(/Application Name/i) as HTMLInputElement;
    await user.clear(appName);
    await user.type(appName, 'Payments Hub');
    expect(appName).toHaveValue('Payments Hub');

    const summary = screen.getByLabelText(/^Summary$/i) as HTMLInputElement;
    await user.clear(summary);
    await user.type(summary, 'Short summary');
    expect(summary).toHaveValue('Short summary');
  });

  test('requesterEmail validation shows and clears error text', async () => {
    const { user } = renderApp();
    const email = screen.getByLabelText(/Requester Email/i) as HTMLInputElement;

    await user.type(email, 'not-an-email');
    expect(await screen.findByText(/Invalid email format/i)).toBeInTheDocument();

    await user.clear(email);
    await user.type(email, 'user@example.com');
    expect(screen.queryByText(/Invalid email format/i)).not.toBeInTheDocument();
  });

  test('environmentsNeeded multi-select adds values and displays them', async () => {
    const { user } = renderApp();

    const envSelect = screen.getByRole('button', { name: /Environments Needed/i });
    await user.click(envSelect);
    await user.click(await screen.findByRole('option', { name: 'DEV1' }));
    await user.click(screen.getByRole('option', { name: 'SIT' }));
    await user.click(envSelect); // close

    expect(envSelect).toHaveTextContent(/DEV1/i);
    expect(envSelect).toHaveTextContent(/SIT/i);
  });

  test('dataFormat multi-select adds values (CSV, PDF)', async () => {
    const { user } = renderApp();

    const formatSelect = screen.getByRole('button', { name: /List of Data Format/i });
    await user.click(formatSelect);
    await user.click(await screen.findByRole('option', { name: 'CSV' }));
    await user.click(screen.getByRole('option', { name: 'PDF' }));
    await user.click(formatSelect);

    expect(formatSelect).toHaveTextContent(/CSV/i);
    expect(formatSelect).toHaveTextContent(/PDF/i);
  });

  test('data classification radio selects "Restricted"', async () => {
    const { user } = renderApp();
    const restricted = screen.getByRole('radio', { name: /Restricted/i }) as HTMLInputElement;
    await user.click(restricted);
    expect(restricted).toBeChecked();
  });

  test('PAN/Credit-Card-in-scope toggles details textarea when Yes', async () => {
    const { user } = renderApp();

    // Click any "Yes" (the group is independent so first works)
    await user.click(screen.getAllByRole('radio', { name: /^Yes$/i })[0]);

    const details = await screen.findByLabelText(/Provide details about PAN\/Credit\/Debit Card data/i);
    await user.type(details, 'Tokenized in transit only');
    expect(details).toHaveValue('Tokenized in transit only');
  });

  test('External Ingress details appear when selecting Yes', async () => {
    const { user } = renderApp();

    await user.click(screen.getAllByRole('radio', { name: /^Yes$/i })[0]);
    const extDetails = screen.getByLabelText(/Provide details to any external systems or Third-party Environments/i);
    await user.type(extDetails, 'Outbound https to vendor ABC');
    expect(extDetails).toHaveValue('Outbound https to vendor ABC');
  });
});
