// src/sideNavbar/boarding/startOnboarding.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';

// ---------- Mocks ----------
const setFormDataMock = jest.fn();
const resetFormDataMock = jest.fn();
let requiredFieldsMock: string[] = [];
let formDataMock: any = {
  trackingStatus: '', // not "Completed" so buttons enabled
  appDetails: {},
  cdmNextDetails: {},
};
const initialFormDataMock = { trackingStatus: '', appDetails: {}, cdmNextDetails: {} };

jest.mock('../FormContext', () => ({
  __esModule: true,
  useFormContext: () => ({
    formData: formDataMock,
    setFormData: setFormDataMock,
    resetFormData: resetFormDataMock,
    requiredFields: requiredFieldsMock,
  }),
  initialFormData: initialFormDataMock,
}));

const makeRequest = jest.fn();
jest.mock('../../services/useApiService', () => ({
  __esModule: true,
  default: () => ({ makeRequest }),
}));

const navigateMock = jest.fn();
let paramsMock: Record<string, string | undefined> = {};
jest.mock('react-router-dom', () => ({
  __esModule: true,
  useNavigate: () => navigateMock,
  useParams: () => paramsMock,
  Link: ({ to, children }: { to: string; children: React.ReactNode }) => (
    <a href={to} data-to={to}>
      {children}
    </a>
  ),
}));

jest.mock('../components/applicationDetails', () => () => <div data-testid="app-details" />);
jest.mock('../components/componentsDetails', () => () => <div data-testid="components-details" />);
jest.mock('../intake-components/guidelinesIntakeForm', () => () => (
  <div data-testid="guidelines" />
));
jest.mock('../../home/CustomNavigation', () => () => <div data-testid="nav" />);

// Expose dialog handlers as buttons we can click in tests
jest.mock('../intake-components/cancelOnboarding', () => (props: any) => (
  <button data-testid="mock-cancel-confirm" onClick={props.handleConfirmCancel} />
));
jest.mock('../intake-components/confirmationOnboarding', () => (props: any) => (
  <button data-testid="mock-submit-confirm" onClick={props.handleConfirmSubmit} />
));

// ---------- SUT ----------
import StartOnboarding from './startOnboarding';

// Small helpers
const click = (el: HTMLElement) => fireEvent.click(el);

describe('StartOnboarding', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    paramsMock = {};
    requiredFieldsMock = [];
    formDataMock = { trackingStatus: '', appDetails: {}, cdmNextDetails: {} };
  });

  test('mount with trackingId → fetches data and shows tracking id', async () => {
    paramsMock = { trackingId: '123' };
    makeRequest.mockResolvedValueOnce({ data: { foo: 'bar' }, status: 200 });

    render(<StartOnboarding />);

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(1));
    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'GET',
        endpoints: expect.stringContaining('/api/intake-form?intakeFormTrackingId=123'),
        responseType: 'json',
      }),
    );
    expect(setFormDataMock).toHaveBeenCalledWith({ foo: 'bar' });

    expect(screen.getByText(/Intake Tracking ID/i)).toBeInTheDocument();
    expect(screen.getByText('123')).toBeInTheDocument();
  });

  test('mount with no trackingId → resets form and shows "Not Available"', async () => {
    paramsMock = {};
    render(<StartOnboarding />);
    expect(resetFormDataMock).toHaveBeenCalled();
    expect(screen.getByText(/Not Available/i)).toBeInTheDocument();
  });

  test('Save → POST /api/intake-form then navigates to /gcpOnboarding/:id', async () => {
    paramsMock = {}; // no fetch on mount
    makeRequest.mockResolvedValueOnce({
      data: { intakeFormTrackingId: 987 },
      status: 200,
    });

    render(<StartOnboarding />);

    click(screen.getByRole('button', { name: /Save/i }));
    await waitFor(() => expect(makeRequest).toHaveBeenCalled());

    expect(makeRequest).toHaveBeenCalledWith(
      expect.objectContaining({
        method: 'POST',
        endpoints: '/api/intake-form',
        responseType: 'json',
        body: expect.any(Object),
      }),
    );
    expect(navigateMock).toHaveBeenCalledWith('/gcpOnboarding/987');
  });

  test('getFormData non-200 → shows error toast', async () => {
    paramsMock = { trackingId: '555' };
    makeRequest.mockResolvedValueOnce({ data: {}, status: 500 });

    render(<StartOnboarding />);

    // Toast appears with error content
    await screen.findByRole('alert');
    expect(screen.getByRole('alert').innerHTML).toMatch(/Error has occurred while fetching Intake Form/i);
  });

  test('Submit invalid → shows validation toast and does not hit submit API', async () => {
    paramsMock = {};
    // Require a field that is missing in formDataMock
    requiredFieldsMock = ['appDetails.name'];
    render(<StartOnboarding />);

    click(screen.getByRole('button', { name: /Submit/i }));

    // Validation toast is shown
    await screen.findByRole('alert');
    expect(screen.getByRole('alert').innerHTML).toMatch(/Please fill in all required fields/i);

    // No submit API call should be made
    expect(
      makeRequest.mock.calls.some((c) => String(c[0]?.endpoints).includes('/api/submit-intake-form')),
    ).toBe(false);
  });

  test('Submit valid → POST /api/submit-intake-form, show success toast, confirm navigates to /inbox', async () => {
    paramsMock = {};
    requiredFieldsMock = []; // no missing fields
    makeRequest.mockResolvedValueOnce({
      data: { intakeFormTrackingId: 4321 },
      status: 200,
    });

    render(<StartOnboarding />);

    click(screen.getByRole('button', { name: /Submit/i }));

    await waitFor(() =>
      expect(
        makeRequest.mock.calls.some((c) =>
          String(c[0]?.endpoints).includes('/api/submit-intake-form'),
        ),
      ).toBe(true),
    );

    // Success toast contains the id
    await screen.findByRole('alert');
    expect(screen.getByRole('alert').innerHTML).toMatch(/submitted succes?fully/i);
    expect(screen.getByRole('alert').innerHTML).toMatch(/4321/);

    // Confirm submit (via mocked dialog)
    click(screen.getByTestId('mock-submit-confirm'));
    expect(navigateMock).toHaveBeenCalledWith('/inbox');
  });

  test('Cancel flow with trackingId → loads existing data again on confirm', async () => {
    paramsMock = { trackingId: '99' };
    makeRequest.mockResolvedValueOnce({ data: { a: 1 }, status: 200 }); // initial mount GET
    makeRequest.mockResolvedValueOnce({ data: { a: 2 }, status: 200 }); // confirm-cancel GET

    render(<StartOnboarding />);

    // Open cancel (click Cancel button), then confirm via mocked dialog button
    click(screen.getByRole('button', { name: /^Cancel$/i }));
    click(screen.getByTestId('mock-cancel-confirm'));

    await waitFor(() => expect(makeRequest).toHaveBeenCalledTimes(2));
    expect(setFormDataMock).toHaveBeenCalledWith({ a: 2 });
  });

  test('Cancel flow without trackingId → resets to initialFormData on confirm', async () => {
    paramsMock = {};
    render(<StartOnboarding />);

    click(screen.getByRole('button', { name: /^Cancel$/i }));
    click(screen.getByTestId('mock-cancel-confirm'));

    expect(setFormDataMock).toHaveBeenCalledWith(initialFormDataMock);
  });

  test('Buttons disabled when trackingStatus === "Completed"', () => {
    formDataMock = { ...formDataMock, trackingStatus: 'Completed' };
    render(<StartOnboarding />);

    expect(screen.getByRole('button', { name: /Save/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /Submit/i })).toBeDisabled();
  });
});
